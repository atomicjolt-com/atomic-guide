# Story 13.1: MCP Implementation Guide - Cloudflare Native Approach

## Quick Start for Developers

This guide provides step-by-step instructions for implementing the MCP server using Cloudflare's native OAuth Provider and MCP Remote pattern.

## Prerequisites

- Cloudflare Workers environment configured
- Access to D1 database and KV namespaces
- Node.js 18+ for local development

## Implementation Steps

### Step 1: Install Dependencies

```bash
npm install @cloudflare/workers-oauth-provider
npm install --save-dev @cloudflare/workers-types
```

### Step 2: Set Up OAuth Provider

Create `/src/features/mcp/server/services/McpOAuthProvider.ts`:

```typescript
import { OAuthProvider } from '@cloudflare/workers-oauth-provider';
import type { Env } from '@/types';

export class McpOAuthProvider {
  private provider: OAuthProvider;

  constructor(env: Env) {
    this.provider = new OAuthProvider({
      // OAuth configuration
      apiRoute: ['/api/mcp/', `${env.PUBLIC_URL}/api/mcp/`],
      apiHandler: this.handleApiRequest.bind(this),
      authorizeEndpoint: `${env.PUBLIC_URL}/mcp/oauth/authorize`,
      tokenEndpoint: `${env.PUBLIC_URL}/mcp/oauth/token`,

      // Security settings
      pkce: true, // Always enforce PKCE
      tokenStorage: env.MCP_TOKENS, // KV namespace for encrypted tokens

      // Client configuration
      clients: {
        'claude-desktop': {
          secret: env.CLAUDE_CLIENT_SECRET,
          redirectUris: ['claude://oauth/callback'],
          scopes: ['learner-dna:read', 'course-progress:read']
        },
        'chatgpt-mcp': {
          secret: env.CHATGPT_CLIENT_SECRET,
          redirectUris: ['https://chat.openai.com/oauth/callback'],
          scopes: ['learner-dna:read', 'course-progress:read']
        }
      }
    });
  }

  async handleApiRequest(request: Request): Promise<Response> {
    // Custom API handling for MCP resources
    const url = new URL(request.url);

    if (url.pathname.startsWith('/api/mcp/resources/')) {
      return this.handleResourceRequest(request);
    }

    return new Response('Not Found', { status: 404 });
  }

  private async handleResourceRequest(request: Request): Promise<Response> {
    // Verify OAuth token and extract user info
    const token = this.provider.getTokenFromRequest(request);
    if (!token) {
      return new Response('Unauthorized', { status: 401 });
    }

    // Route to appropriate resource handler
    // Implementation continues...
  }
}
```

### Step 3: Implement MCP Remote Handler with Durable Objects

Create `/src/features/mcp/server/handlers/McpSessionDO.ts`:

```typescript
import { DurableObject } from 'cloudflare:workers';

export class McpSessionDurableObject extends DurableObject {
  private sessions: Map<string, McpSession> = new Map();
  private sseConnections: Map<string, ReadableStreamDefaultController> = new Map();

  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);

    // Handle SSE connection for MCP protocol
    if (url.pathname === '/sse') {
      return this.handleSSEConnection(request);
    }

    // Handle MCP protocol messages
    if (url.pathname === '/message') {
      return this.handleMcpMessage(request);
    }

    return new Response('Not Found', { status: 404 });
  }

  private handleSSEConnection(request: Request): Response {
    const clientId = request.headers.get('x-client-id');
    if (!clientId) {
      return new Response('Client ID required', { status: 400 });
    }

    // Create SSE stream
    const { readable, writable } = new TransformStream();
    const writer = writable.getWriter();
    const encoder = new TextEncoder();

    // Store controller for sending messages
    this.sseConnections.set(clientId, writer);

    // Send initial connection success
    writer.write(encoder.encode('event: connected\ndata: {"status":"ready"}\n\n'));

    // Handle disconnection
    request.signal.addEventListener('abort', () => {
      this.sseConnections.delete(clientId);
      this.sessions.delete(clientId);
    });

    return new Response(readable, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });
  }

  private async handleMcpMessage(request: Request): Promise<Response> {
    const clientId = request.headers.get('x-client-id');
    const message = await request.json() as McpMessage;

    // Process MCP protocol messages
    switch (message.method) {
      case 'initialize':
        return this.handleInitialize(clientId, message);
      case 'list_resources':
        return this.handleListResources(clientId);
      case 'read_resource':
        return this.handleReadResource(clientId, message);
      default:
        return new Response('Unknown method', { status: 400 });
    }
  }

  private async handleInitialize(clientId: string, message: McpMessage): Promise<Response> {
    // Initialize MCP session
    this.sessions.set(clientId, {
      id: clientId,
      capabilities: message.params?.capabilities || {},
      createdAt: new Date(),
    });

    // Send capabilities via SSE
    const controller = this.sseConnections.get(clientId);
    if (controller) {
      const encoder = new TextEncoder();
      await controller.write(encoder.encode(
        `event: capabilities\ndata: ${JSON.stringify({
          capabilities: {
            resources: {
              list: true,
              read: true,
            },
            tools: {
              list: false,
              call: false,
            }
          }
        })}\n\n`
      ));
    }

    return new Response(JSON.stringify({ status: 'initialized' }));
  }

  private async handleListResources(clientId: string): Promise<Response> {
    // Return available resources for this user
    const resources = [
      {
        uri: 'learner-dna://profile',
        name: 'Learner DNA Profile',
        description: 'Complete cognitive learning profile',
        mimeType: 'application/json',
      },
      {
        uri: 'learner-dna://patterns',
        name: 'Learning Patterns',
        description: 'Identified learning patterns and preferences',
        mimeType: 'application/json',
      },
      {
        uri: 'course://progress',
        name: 'Course Progress',
        description: 'Progress across all enrolled courses',
        mimeType: 'application/json',
      },
    ];

    return new Response(JSON.stringify({ resources }));
  }

  private async handleReadResource(clientId: string, message: McpMessage): Promise<Response> {
    const { uri } = message.params || {};

    // Fetch actual data based on resource URI
    // This would integrate with LearnerDnaExportService
    const resourceData = await this.fetchResourceData(uri, clientId);

    return new Response(JSON.stringify({
      contents: [{
        uri,
        mimeType: 'application/json',
        text: JSON.stringify(resourceData),
      }]
    }));
  }

  private async fetchResourceData(uri: string, clientId: string): Promise<any> {
    // Integration point with existing services
    // Implementation would call LearnerDnaExportService
    return { placeholder: 'Resource data would be fetched here' };
  }
}
```

### Step 4: Wire Up Routes in Hono

Update `/src/index.ts`:

```typescript
import { Hono } from 'hono';
import { McpOAuthProvider } from '@/features/mcp/server/services/McpOAuthProvider';

const app = new Hono<{ Bindings: Env }>();

// MCP OAuth endpoints (handled by Cloudflare OAuth Provider)
app.get('/mcp/oauth/authorize', async (c) => {
  const provider = new McpOAuthProvider(c.env);
  return provider.handleAuthorize(c.req.raw);
});

app.post('/mcp/oauth/token', async (c) => {
  const provider = new McpOAuthProvider(c.env);
  return provider.handleToken(c.req.raw);
});

// MCP SSE endpoint (Durable Object)
app.get('/mcp/sse', async (c) => {
  const clientId = c.req.header('x-client-id');
  const id = c.env.MCP_SESSIONS.idFromName(clientId);
  const stub = c.env.MCP_SESSIONS.get(id);
  return stub.fetch(c.req.raw);
});

// MCP protocol endpoints (Durable Object)
app.post('/mcp/:method', async (c) => {
  const clientId = c.req.header('x-client-id');
  const id = c.env.MCP_SESSIONS.idFromName(clientId);
  const stub = c.env.MCP_SESSIONS.get(id);

  const url = new URL(c.req.url);
  url.pathname = '/message';

  return stub.fetch(new Request(url, {
    method: 'POST',
    headers: c.req.raw.headers,
    body: c.req.raw.body,
  }));
});

// Protected API endpoints for resources
app.get('/api/mcp/resources/*', async (c) => {
  const provider = new McpOAuthProvider(c.env);
  return provider.handleApiRequest(c.req.raw);
});
```

### Step 5: Update Wrangler Configuration

Add to `wrangler.jsonc`:

```jsonc
{
  "name": "atomic-guide",
  "main": "src/index.ts",

  // Add KV namespace for MCP tokens
  "kv_namespaces": [
    {
      "binding": "MCP_TOKENS",
      "id": "your-kv-namespace-id",
      "preview_id": "your-preview-kv-id"
    }
  ],

  // Add Durable Object for MCP sessions
  "durable_objects": {
    "bindings": [
      {
        "name": "MCP_SESSIONS",
        "class_name": "McpSessionDurableObject"
      }
    ]
  },

  // Environment variables
  "vars": {
    "CLAUDE_CLIENT_SECRET": "generate-secure-secret",
    "CHATGPT_CLIENT_SECRET": "generate-secure-secret",
    "PUBLIC_URL": "https://guide.atomicjolt.xyz"
  }
}
```

### Step 6: Database Migration

Run the simplified migration for consent tracking:

```sql
-- migrations/add_mcp_consent.sql
CREATE TABLE IF NOT EXISTS mcp_user_consent (
    id TEXT PRIMARY KEY,
    tenant_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    external_client_id TEXT NOT NULL,
    scopes TEXT NOT NULL, -- JSON array
    granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,
    revoked_at TIMESTAMP,
    FOREIGN KEY (tenant_id) REFERENCES tenants(id)
);

CREATE TABLE IF NOT EXISTS mcp_access_logs (
    id TEXT PRIMARY KEY,
    client_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    tenant_id TEXT NOT NULL,
    resource_type TEXT NOT NULL,
    resource_id TEXT,
    action TEXT NOT NULL,
    ip_address TEXT,
    user_agent TEXT,
    accessed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (tenant_id) REFERENCES tenants(id)
);

CREATE INDEX idx_mcp_consent_user ON mcp_user_consent(user_id);
CREATE INDEX idx_mcp_consent_client ON mcp_user_consent(external_client_id);
CREATE INDEX idx_mcp_logs_user ON mcp_access_logs(user_id);
```

## Testing the Implementation

### Local Testing with Wrangler

```bash
# Start local development server
npm run dev

# In another terminal, test OAuth flow
curl -X GET "http://localhost:8787/mcp/oauth/authorize?client_id=claude-desktop&redirect_uri=claude://oauth/callback&response_type=code&scope=learner-dna:read"

# Test SSE connection
curl -N -H "x-client-id: test-client" \
     -H "Authorization: Bearer YOUR_TOKEN" \
     http://localhost:8787/mcp/sse
```

### Integration with Claude Desktop

1. Configure Claude Desktop MCP settings:

```json
{
  "mcpServers": {
    "atomic-guide": {
      "url": "https://guide.atomicjolt.xyz/mcp",
      "oauth": {
        "clientId": "claude-desktop",
        "authorizationUrl": "https://guide.atomicjolt.xyz/mcp/oauth/authorize",
        "tokenUrl": "https://guide.atomicjolt.xyz/mcp/oauth/token",
        "scopes": ["learner-dna:read", "course-progress:read"]
      }
    }
  }
}
```

2. Test the connection in Claude Desktop
3. Verify Learner DNA resources are accessible

## Security Checklist

- [ ] OAuth client secrets stored securely in environment variables
- [ ] PKCE enforced for all OAuth flows
- [ ] Token encryption enabled in KV storage
- [ ] Rate limiting configured for API endpoints
- [ ] CORS headers properly configured
- [ ] Audit logging implemented for all resource access
- [ ] Privacy consent verification before data exposure
- [ ] Cross-tenant isolation validated

## Monitoring & Observability

Add monitoring for:

```typescript
// Track MCP metrics
export async function trackMcpMetrics(env: Env, metric: McpMetric) {
  await env.ANALYTICS.writeDataPoint({
    blobs: [metric.clientId, metric.resource, metric.action],
    doubles: [metric.responseTime],
    indexes: [metric.userId],
  });
}
```

## Troubleshooting

### Common Issues

1. **SSE Connection Drops**
   - Check Cloudflare timeout settings (max 15 minutes)
   - Implement heartbeat messages every 30 seconds

2. **OAuth Token Issues**
   - Verify KV namespace is properly configured
   - Check token expiration settings

3. **Durable Object Errors**
   - Ensure DO class is exported in main worker
   - Check DO namespace binding in wrangler.jsonc

## References

- [Cloudflare Workers OAuth Provider](https://github.com/cloudflare/workers-oauth-provider)
- [MCP Remote Demo](https://github.com/cloudflare/ai/tree/main/demos/remote-mcp-github-oauth)
- [MCP Protocol Specification](https://spec.modelcontextprotocol.io/)
- [Cloudflare Durable Objects](https://developers.cloudflare.com/durable-objects/)

## Next Steps

1. Implement privacy consent UI in React client
2. Add comprehensive error handling
3. Set up monitoring dashboards
4. Conduct security audit
5. Performance testing with multiple concurrent clients