# Story 6.1: Cross-Course Intelligence - Frontend Implementation Guide

## Technical Architecture Overview

This document bridges the UI/UX specifications with the actual technical implementation, providing detailed guidance for developers building the Cross-Course Intelligence Foundation feature.

## Component Architecture

### 1. Directory Structure

Following the vertical slice architecture pattern:

```
src/features/cross-course-intelligence/
â”œâ”€â”€ client/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ CrossCoursePerformanceDashboard.tsx
â”‚   â”‚   â”œâ”€â”€ AcademicRiskIndicator.tsx
â”‚   â”‚   â”œâ”€â”€ KnowledgeDependencyGraph.tsx
â”‚   â”‚   â”œâ”€â”€ InstructorGapAlertDashboard.tsx
â”‚   â”‚   â”œâ”€â”€ CrossCourseConsentManager.tsx
â”‚   â”‚   â”œâ”€â”€ EnhancedChatInterface.tsx
â”‚   â”‚   â””â”€â”€ __tests__/
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ useCrossCourseData.ts
â”‚   â”‚   â”œâ”€â”€ useKnowledgeGraph.ts
â”‚   â”‚   â””â”€â”€ useConsentSettings.ts
â”‚   â”œâ”€â”€ stores/
â”‚   â”‚   â”œâ”€â”€ crossCourseStore.ts
â”‚   â”‚   â””â”€â”€ consentStore.ts
â”‚   â””â”€â”€ styles/
â”‚       â”œâ”€â”€ cross-course-dashboard.module.css
â”‚       â”œâ”€â”€ knowledge-graph.module.css
â”‚       â”œâ”€â”€ instructor-alerts.module.css
â”‚       â””â”€â”€ consent-manager.module.css
â”œâ”€â”€ server/
â”‚   â”œâ”€â”€ handlers/
â”‚   â”œâ”€â”€ services/
â”‚   â””â”€â”€ repositories/
â””â”€â”€ shared/
    â”œâ”€â”€ types/
    â””â”€â”€ schemas/
```

### 2. Core Components Specification

#### CrossCoursePerformanceDashboard Component

**Props Interface:**
```typescript
interface CrossCoursePerformanceDashboardProps {
  studentId: string;
  jwt: string;
  onViewChange?: (view: DashboardView) => void;
  initialView?: DashboardView;
}

type DashboardView = 'overview' | 'dependencies' | 'gaps' | 'trends';

interface DashboardData {
  academicRiskScore: number;
  riskFactors: RiskFactor[];
  activeCourses: CourseStatus[];
  knowledgeDependencies: KnowledgeDependency[];
  actionItems: ActionItem[];
  performanceCorrelations: PerformanceCorrelation[];
}
```

**Component Structure:**
```typescript
export function CrossCoursePerformanceDashboard({
  studentId,
  jwt,
  onViewChange,
  initialView = 'overview'
}: CrossCoursePerformanceDashboardProps): ReactElement {
  const [activeView, setActiveView] = useState<DashboardView>(initialView);
  const { data, loading, error } = useCrossCourseData(studentId, jwt);
  
  // Component implementation
  return (
    <div className={styles.dashboard}>
      <DashboardHeader />
      <DashboardTabs activeView={activeView} onViewChange={handleViewChange} />
      <DashboardContent view={activeView} data={data} />
    </div>
  );
}
```

**CSS Module Structure:**
```css
/* cross-course-dashboard.module.css */
.dashboard {
  width: 100%;
  background: var(--aj-white);
  min-height: 600px;
}

.dashboardHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--aj-neutral-lightest);
}

.riskIndicator {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.riskScore {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  position: relative;
}

.riskScore.high {
  background: conic-gradient(var(--aj-error-red) 0deg 252deg, var(--aj-neutral-lightest) 252deg);
  color: var(--aj-error-red);
}

.riskScore.medium {
  background: conic-gradient(var(--aj-yellow) 0deg 234deg, var(--aj-neutral-lightest) 234deg);
  color: var(--aj-yellow-dark);
}

.riskScore.low {
  background: conic-gradient(var(--aj-success-green) 0deg 108deg, var(--aj-neutral-lightest) 108deg);
  color: var(--aj-success-green);
}

.courseGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 1rem;
  margin-bottom: 2rem;
}

.courseCard {
  background: var(--aj-white);
  border: 1px solid var(--aj-neutral-lightest);
  border-radius: 8px;
  padding: 1rem;
  box-shadow: var(--shadow-small);
  transition: all 0.2s ease;
}

.courseCard:hover {
  box-shadow: var(--shadow-medium);
  transform: translateY(-2px);
}

@media (max-width: 768px) {
  .courseGrid {
    grid-template-columns: 1fr;
  }
  
  .dashboardHeader {
    flex-direction: column;
    gap: 1rem;
    align-items: flex-start;
  }
}
```

#### KnowledgeDependencyGraph Component

**Implementation with React + D3.js:**
```typescript
interface KnowledgeDependencyGraphProps {
  dependencies: KnowledgeDependency[];
  courses: Course[];
  selectedCourse?: string;
  onCourseSelect?: (courseId: string) => void;
  interactive?: boolean;
}

export function KnowledgeDependencyGraph({
  dependencies,
  courses,
  selectedCourse,
  onCourseSelect,
  interactive = true
}: KnowledgeDependencyGraphProps): ReactElement {
  const svgRef = useRef<SVGSVGElement>(null);
  const [dimensions, setDimensions] = useState({ width: 800, height: 600 });
  
  useEffect(() => {
    if (!svgRef.current || !dependencies.length) return;
    
    const svg = d3.select(svgRef.current);
    
    // Create force simulation for network layout
    const simulation = d3.forceSimulation(courses)
      .force('link', d3.forceLink(dependencies).id(d => d.id).strength(0.8))
      .force('charge', d3.forceManyBody().strength(-300))
      .force('center', d3.forceCenter(dimensions.width / 2, dimensions.height / 2));
    
    // Render nodes and links
    renderGraph(svg, simulation, interactive, onCourseSelect);
    
    return () => simulation.stop();
  }, [dependencies, courses, selectedCourse, interactive]);
  
  return (
    <div className={styles.graphContainer}>
      <svg
        ref={svgRef}
        width={dimensions.width}
        height={dimensions.height}
        className={styles.dependencyGraph}
        role="img"
        aria-label="Knowledge dependency graph showing course relationships"
      >
        <title>Course Dependency Network</title>
      </svg>
      <GraphLegend />
      <GraphControls onZoom={handleZoom} onReset={handleReset} />
    </div>
  );
}
```

#### InstructorGapAlertDashboard Component

**Component Interface:**
```typescript
interface InstructorGapAlertDashboardProps {
  instructorId: string;
  courseId: string;
  jwt: string;
}

interface GapAlert {
  id: string;
  studentId: string;
  studentName: string;
  studentEmail: string;
  gapArea: string;
  prerequisiteCourse: string;
  affectedCourse: string;
  riskScore: number;
  impactDate: Date;
  recommendations: InterventionRecommendation[];
  status: 'new' | 'acknowledged' | 'in-progress' | 'resolved';
  createdAt: Date;
  updatedAt: Date;
}

export function InstructorGapAlertDashboard({
  instructorId,
  courseId,
  jwt
}: InstructorGapAlertDashboardProps): ReactElement {
  const [alerts, setAlerts] = useState<GapAlert[]>([]);
  const [selectedAlert, setSelectedAlert] = useState<string | null>(null);
  const [filterBy, setFilterBy] = useState<AlertFilter>('all');
  const [sortBy, setSortBy] = useState<AlertSort>('risk-score');
  
  const { 
    data: alertData, 
    loading, 
    error,
    refetch 
  } = useGapAlerts(instructorId, courseId, jwt);
  
  const handleAlertAction = async (
    alertId: string, 
    action: AlertAction
  ): Promise<void> => {
    // Implementation for alert actions
  };
  
  return (
    <div className={styles.alertDashboard}>
      <AlertSummary alerts={alerts} />
      <AlertFilters 
        filterBy={filterBy}
        sortBy={sortBy}
        onFilterChange={setFilterBy}
        onSortChange={setSortBy}
      />
      <AlertTable 
        alerts={filteredAndSortedAlerts}
        selectedAlert={selectedAlert}
        onAlertSelect={setSelectedAlert}
        onAlertAction={handleAlertAction}
      />
      {selectedAlert && (
        <AlertDetailPanel
          alert={alerts.find(a => a.id === selectedAlert)}
          onClose={() => setSelectedAlert(null)}
          onAction={handleAlertAction}
        />
      )}
    </div>
  );
}
```

### 3. Data Management with React Query

#### Custom Hooks for Data Fetching

```typescript
// useCrossCourseData.ts
export function useCrossCourseData(studentId: string, jwt: string) {
  return useQuery({
    queryKey: ['crossCourseData', studentId],
    queryFn: () => fetchCrossCourseData(studentId, jwt),
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
    refetchInterval: 30 * 1000, // 30 seconds for real-time updates
    retry: 3,
    onError: (error) => {
      console.error('Failed to fetch cross-course data:', error);
      // Track error for monitoring
    }
  });
}

// useKnowledgeGraph.ts
export function useKnowledgeGraph(studentId: string, jwt: string) {
  return useQuery({
    queryKey: ['knowledgeGraph', studentId],
    queryFn: () => fetchKnowledgeGraph(studentId, jwt),
    staleTime: 10 * 60 * 1000, // 10 minutes (more stable data)
    select: (data) => {
      // Transform raw API data into graph-friendly format
      return {
        nodes: data.courses.map(course => ({
          id: course.id,
          name: course.name,
          performance: course.performance,
          status: course.status
        })),
        links: data.dependencies.map(dep => ({
          source: dep.prerequisiteCourse,
          target: dep.dependentCourse,
          strength: dep.dependencyStrength
        }))
      };
    }
  });
}

// useConsentSettings.ts
export function useConsentSettings(studentId: string, jwt: string) {
  const queryClient = useQueryClient();
  
  const query = useQuery({
    queryKey: ['consentSettings', studentId],
    queryFn: () => fetchConsentSettings(studentId, jwt),
    staleTime: Infinity, // Consent settings change infrequently
  });
  
  const updateConsent = useMutation({
    mutationFn: (consent: ConsentUpdate) => 
      updateConsentSettings(studentId, consent, jwt),
    onSuccess: () => {
      queryClient.invalidateQueries(['consentSettings', studentId]);
      queryClient.invalidateQueries(['crossCourseData', studentId]);
    }
  });
  
  return {
    ...query,
    updateConsent: updateConsent.mutate,
    isUpdating: updateConsent.isLoading
  };
}
```

### 4. State Management with Zustand

#### Cross-Course Store

```typescript
// crossCourseStore.ts
interface CrossCourseState {
  // Dashboard state
  activeView: DashboardView;
  selectedCourse: string | null;
  
  // Filter states
  alertFilter: AlertFilter;
  alertSort: AlertSort;
  
  // UI states
  showOnboardingTour: boolean;
  collapsedSections: Set<string>;
  
  // Actions
  setActiveView: (view: DashboardView) => void;
  setSelectedCourse: (courseId: string | null) => void;
  setAlertFilter: (filter: AlertFilter) => void;
  setAlertSort: (sort: AlertSort) => void;
  toggleSection: (sectionId: string) => void;
  completeOnboarding: () => void;
}

export const useCrossCourseStore = create<CrossCourseState>((set, get) => ({
  activeView: 'overview',
  selectedCourse: null,
  alertFilter: 'all',
  alertSort: 'risk-score',
  showOnboardingTour: true,
  collapsedSections: new Set(),
  
  setActiveView: (view) => set({ activeView: view }),
  setSelectedCourse: (courseId) => set({ selectedCourse: courseId }),
  setAlertFilter: (filter) => set({ alertFilter: filter }),
  setAlertSort: (sort) => set({ alertSort: sort }),
  
  toggleSection: (sectionId) => set((state) => {
    const newCollapsed = new Set(state.collapsedSections);
    if (newCollapsed.has(sectionId)) {
      newCollapsed.delete(sectionId);
    } else {
      newCollapsed.add(sectionId);
    }
    return { collapsedSections: newCollapsed };
  }),
  
  completeOnboarding: () => set({ showOnboardingTour: false })
}));
```

### 5. Enhanced Chat Integration

#### Chat Context Provider

```typescript
// CrossCourseContextProvider.tsx
interface CrossCourseContextProviderProps {
  children: ReactNode;
  studentId: string;
  jwt: string;
}

export function CrossCourseContextProvider({
  children,
  studentId,
  jwt
}: CrossCourseContextProviderProps): ReactElement {
  const { data: crossCourseData } = useCrossCourseData(studentId, jwt);
  
  const contextValue = useMemo(() => ({
    hasMultipleCourses: crossCourseData?.courses.length > 1,
    knowledgeGaps: crossCourseData?.actionItems.filter(item => 
      item.type === 'knowledge-gap'
    ) || [],
    courseConnections: crossCourseData?.dependencies || [],
    enableProactiveAlerts: crossCourseData?.settings.enableProactiveAlerts
  }), [crossCourseData]);
  
  return (
    <CrossCourseContext.Provider value={contextValue}>
      {children}
    </CrossCourseContext.Provider>
  );
}

// Enhanced Chat Message Component
export function EnhancedChatMessage({
  message,
  isFromUser
}: EnhancedChatMessageProps): ReactElement {
  const crossCourseContext = useContext(CrossCourseContext);
  
  const renderCrossCourseContext = () => {
    if (isFromUser || !message.crossCourseContext?.length) {
      return null;
    }
    
    return (
      <div className={styles.crossCourseContext}>
        <h4 className={styles.contextHeader}>
          ðŸ“š Cross-Course Context
        </h4>
        <div className={styles.contextContent}>
          {message.crossCourseContext.map((context, index) => (
            <div key={index} className={styles.contextItem}>
              <span className={styles.courseName}>
                {context.courseName}:
              </span>
              <span className={styles.contextDescription}>
                {context.description}
              </span>
            </div>
          ))}
        </div>
        {message.knowledgeTransferOpportunities?.length > 0 && (
          <div className={styles.transferOpportunities}>
            <h5>ðŸ’¡ Learning Connections:</h5>
            {message.knowledgeTransferOpportunities.map((opportunity, index) => (
              <button
                key={index}
                className={styles.opportunityButton}
                onClick={() => handleExploreOpportunity(opportunity)}
              >
                {opportunity.description}
              </button>
            ))}
          </div>
        )}
      </div>
    );
  };
  
  return (
    <div className={`${styles.message} ${isFromUser ? styles.userMessage : styles.assistantMessage}`}>
      <div className={styles.messageContent}>
        {message.content}
      </div>
      {renderCrossCourseContext()}
      {message.prerequisiteLinks?.length > 0 && (
        <PrerequisiteLinksDisplay links={message.prerequisiteLinks} />
      )}
    </div>
  );
}
```

### 6. Accessibility Implementation

#### WCAG AA+ Compliance Features

```typescript
// AccessibilityEnhanced Components
export function AccessibleRiskIndicator({ 
  riskScore, 
  riskLevel 
}: RiskIndicatorProps): ReactElement {
  const ariaLabel = `Academic risk level: ${riskLevel}, score ${riskScore} out of 1.0`;
  const description = getRiskDescription(riskLevel, riskScore);
  
  return (
    <div 
      className={styles.riskIndicator}
      role="img"
      aria-label={ariaLabel}
      aria-describedby="risk-description"
    >
      <div 
        className={`${styles.riskScore} ${styles[riskLevel]}`}
        aria-hidden="true"
      >
        {Math.round(riskScore * 100)}%
      </div>
      <div id="risk-description" className="sr-only">
        {description}
      </div>
      <RiskFactorsList factors={getRiskFactors(riskScore)} />
    </div>
  );
}

// Keyboard Navigation for Graph
export function AccessibleKnowledgeGraph({
  dependencies,
  courses
}: KnowledgeGraphProps): ReactElement {
  const [focusedNode, setFocusedNode] = useState<string | null>(null);
  const [announceText, setAnnounceText] = useState<string>('');
  
  const handleKeyboardNavigation = (event: KeyboardEvent) => {
    switch (event.key) {
      case 'Tab':
        // Navigate between course nodes
        navigateToNextNode();
        break;
      case 'Enter':
      case ' ':
        // Select/examine course
        if (focusedNode) {
          examineNode(focusedNode);
        }
        break;
      case 'Escape':
        // Exit graph focus
        exitGraphFocus();
        break;
    }
  };
  
  const examineNode = (nodeId: string) => {
    const course = courses.find(c => c.id === nodeId);
    const connections = dependencies.filter(d => 
      d.prerequisiteCourse === nodeId || d.dependentCourse === nodeId
    );
    
    const announcement = `
      ${course?.name}: Performance ${course?.performance}%. 
      Connected to ${connections.length} other courses. 
      Prerequisites: ${connections.filter(c => c.dependentCourse === nodeId).length}.
      Dependents: ${connections.filter(c => c.prerequisiteCourse === nodeId).length}.
    `;
    
    setAnnounceText(announcement);
    
    // Also provide detailed connection information
    setTimeout(() => {
      const detailAnnouncement = connections
        .map(conn => `${conn.prerequisiteCourse} leads to ${conn.dependentCourse}`)
        .join('. ');
      setAnnounceText(detailAnnouncement);
    }, 2000);
  };
  
  return (
    <div 
      className={styles.graphContainer}
      onKeyDown={handleKeyboardNavigation}
      tabIndex={0}
      role="application"
      aria-label="Knowledge dependency graph. Use Tab to navigate, Enter to examine."
    >
      <div 
        aria-live="polite" 
        aria-atomic="true"
        className="sr-only"
      >
        {announceText}
      </div>
      
      <svg className={styles.dependencyGraph} aria-hidden="true">
        {/* Visual graph implementation */}
      </svg>
      
      {/* Alternative table representation for screen readers */}
      <table className="sr-only">
        <caption>Course dependency relationships</caption>
        <thead>
          <tr>
            <th>Prerequisite Course</th>
            <th>Dependent Course</th>
            <th>Dependency Strength</th>
          </tr>
        </thead>
        <tbody>
          {dependencies.map((dep, index) => (
            <tr key={index}>
              <td>{dep.prerequisiteCourse}</td>
              <td>{dep.dependentCourse}</td>
              <td>{dep.dependencyStrength}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

### 7. Performance Optimization

#### Code Splitting and Lazy Loading

```typescript
// Lazy load heavy components
const KnowledgeDependencyGraph = lazy(() => 
  import('./KnowledgeDependencyGraph').then(module => ({
    default: module.KnowledgeDependencyGraph
  }))
);

const InstructorGapAlertDashboard = lazy(() => 
  import('./InstructorGapAlertDashboard').then(module => ({
    default: module.InstructorGapAlertDashboard
  }))
);

// Virtualization for large lists
export function VirtualizedAlertList({ 
  alerts 
}: VirtualizedAlertListProps): ReactElement {
  const parentRef = useRef<HTMLDivElement>(null);
  
  const virtualizer = useVirtualizer({
    count: alerts.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 120, // Alert row height
    overscan: 5
  });
  
  return (
    <div 
      ref={parentRef}
      className={styles.alertList}
      style={{ height: '600px', overflow: 'auto' }}
    >
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          width: '100%',
          position: 'relative'
        }}
      >
        {virtualizer.getVirtualItems().map(virtualItem => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: `${virtualItem.size}px`,
              transform: `translateY(${virtualItem.start}px)`
            }}
          >
            <AlertRow alert={alerts[virtualItem.index]} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

#### Optimized Data Processing

```typescript
// Memoized computations for expensive operations
export function useMemoizedCourseAnalysis(courses: Course[]) {
  return useMemo(() => {
    // Expensive computation for course relationships
    const riskAnalysis = computeRiskAnalysis(courses);
    const performanceCorrelations = computePerformanceCorrelations(courses);
    const learningPathOptimization = optimizeLearningPaths(courses);
    
    return {
      riskAnalysis,
      performanceCorrelations,
      learningPathOptimization
    };
  }, [courses]);
}

// Debounced API calls for real-time features
export function useDebouncedupdateConsent() {
  return useCallback(
    debounce(async (consentData: ConsentUpdate) => {
      try {
        await updateConsentSettings(consentData);
      } catch (error) {
        console.error('Failed to update consent:', error);
      }
    }, 1000),
    []
  );
}
```

### 8. Testing Strategy

#### Component Testing with React Testing Library

```typescript
// CrossCoursePerformanceDashboard.test.tsx
describe('CrossCoursePerformanceDashboard', () => {
  const mockData = {
    academicRiskScore: 0.65,
    activeCourses: [
      { id: 'math101', name: 'Math 101', performance: 0.8 },
      { id: 'physics101', name: 'Physics 101', performance: 0.4 }
    ],
    actionItems: [
      {
        id: '1',
        type: 'knowledge-gap',
        priority: 'high',
        description: 'Review quadratic equations'
      }
    ]
  };
  
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  it('displays academic risk score correctly', async () => {
    render(
      <QueryClient client={queryClient}>
        <CrossCoursePerformanceDashboard 
          studentId="student123"
          jwt="mock-jwt"
        />
      </QueryClient>
    );
    
    await waitFor(() => {
      expect(screen.getByRole('img', { name: /academic risk level/i }))
        .toBeInTheDocument();
    });
    
    expect(screen.getByText('65%')).toBeInTheDocument();
    expect(screen.getByText(/medium risk/i)).toBeInTheDocument();
  });
  
  it('handles keyboard navigation in dashboard tabs', async () => {
    const user = userEvent.setup();
    render(<CrossCoursePerformanceDashboard {...props} />);
    
    const overviewTab = screen.getByRole('tab', { name: /overview/i });
    const dependenciesTab = screen.getByRole('tab', { name: /dependencies/i });
    
    await user.tab(); // Focus first tab
    expect(overviewTab).toHaveFocus();
    
    await user.keyboard('{ArrowRight}');
    expect(dependenciesTab).toHaveFocus();
  });
  
  it('provides accessible descriptions for risk indicators', () => {
    render(<CrossCoursePerformanceDashboard {...props} />);
    
    const riskIndicator = screen.getByRole('img', { 
      name: /academic risk level: medium, score 0.65/i 
    });
    
    expect(riskIndicator).toHaveAttribute('aria-describedby');
    
    const description = screen.getByText(/primary risk factors/i);
    expect(description).toBeInTheDocument();
  });
});
```

#### Integration Testing

```typescript
// CrossCourseFeature.integration.test.tsx
describe('Cross-Course Intelligence Integration', () => {
  it('updates dashboard when consent settings change', async () => {
    const { rerender } = render(
      <CrossCourseProvider studentId="student123" jwt="mock-jwt">
        <CrossCoursePerformanceDashboard />
        <CrossCourseConsentManager />
      </CrossCourseProvider>
    );
    
    // Initial state - limited data sharing
    await waitFor(() => {
      expect(screen.getByText(/limited insights/i)).toBeInTheDocument();
    });
    
    // Enable full data sharing
    const fullSharingToggle = screen.getByRole('switch', { 
      name: /allow all course data sharing/i 
    });
    
    await userEvent.click(fullSharingToggle);
    
    // Dashboard should update with enhanced insights
    await waitFor(() => {
      expect(screen.getByText(/enhanced cross-course insights/i))
        .toBeInTheDocument();
    });
    
    // Verify API calls were made in correct order
    expect(mockUpdateConsent).toHaveBeenCalledWith({
      studentId: 'student123',
      consentType: 'all',
      consentGranted: true
    });
    
    expect(mockFetchCrossCourseData).toHaveBeenCalledWith(
      'student123',
      expect.objectContaining({ fullAccess: true })
    );
  });
});
```

### 9. Error Handling and Loading States

#### Comprehensive Error Boundaries

```typescript
// CrossCourseErrorBoundary.tsx
export class CrossCourseErrorBoundary extends Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Cross-course feature error:', error, errorInfo);
    
    // Track error for monitoring
    trackError('cross-course-intelligence', {
      error: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack
    });
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className={styles.errorContainer}>
          <h2>Cross-Course Insights Temporarily Unavailable</h2>
          <p>
            Don't worry - your individual course analytics are still available.
          </p>
          <details className={styles.errorDetails}>
            <summary>Technical Details</summary>
            <pre>{this.state.error?.message}</pre>
          </details>
          <div className={styles.errorActions}>
            <button 
              onClick={() => window.location.reload()}
              className={styles.retryButton}
            >
              Retry
            </button>
            <button 
              onClick={() => this.props.onFallback?.()}
              className={styles.fallbackButton}
            >
              Use Single-Course View
            </button>
          </div>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

#### Loading States with Skeleton UI

```typescript
// DashboardSkeleton.tsx
export function DashboardSkeleton(): ReactElement {
  return (
    <div className={styles.skeletonContainer}>
      <div className={styles.skeletonHeader}>
        <div className={styles.skeletonTitle} />
        <div className={styles.skeletonSubtitle} />
      </div>
      
      <div className={styles.skeletonTabs}>
        {Array.from({ length: 4 }, (_, i) => (
          <div key={i} className={styles.skeletonTab} />
        ))}
      </div>
      
      <div className={styles.skeletonContent}>
        <div className={styles.skeletonCard}>
          <div className={styles.skeletonRiskScore} />
          <div className={styles.skeletonText} />
          <div className={styles.skeletonText} />
        </div>
        
        <div className={styles.skeletonGrid}>
          {Array.from({ length: 3 }, (_, i) => (
            <div key={i} className={styles.skeletonCourseCard}>
              <div className={styles.skeletonCourseName} />
              <div className={styles.skeletonPerformance} />
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

/* Skeleton CSS animations */
.skeletonTitle,
.skeletonTab,
.skeletonText {
  background: linear-gradient(90deg, 
    var(--aj-neutral-lightest) 25%, 
    var(--aj-neutral-light) 50%, 
    var(--aj-neutral-lightest) 75%
  );
  background-size: 200% 100%;
  animation: loading 1.5s infinite;
}

@keyframes loading {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}
```

This comprehensive implementation guide provides developers with detailed technical specifications for building the Cross-Course Intelligence Foundation feature, ensuring consistency with the project's architecture patterns and maintaining high code quality standards.